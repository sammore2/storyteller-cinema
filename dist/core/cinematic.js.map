{"version":3,"file":"cinematic.js","sources":["../../src/scripts/core/cinematic.js"],"sourcesContent":["import { applyVisualDepth } from './depth.js';\r\n\r\nexport function createOverlay() {\r\n    if (document.getElementById('storyteller-cinema-overlay')) return;\r\n    const overlay = document.createElement('div');\r\n    overlay.id = 'storyteller-cinema-overlay';\r\n    overlay.innerHTML = '<div class=\"cinematic-bar top\"></div><div class=\"cinematic-bar bottom\"></div>';\r\n    document.body.appendChild(overlay);\r\n}\r\n\r\n// -----------------------------------------------------------------------------\r\n// HELPER: Wait for Ghost Mode \r\n// -----------------------------------------------------------------------------\r\nasync function ensureGhostMode(targetState, force = false) {\r\n    const currentState = game.settings.get(\"core\", \"unconstrainedMovement\");\r\n    if (currentState === targetState && !force) return;\r\n    try {\r\n        await game.settings.set(\"core\", \"unconstrainedMovement\", targetState);\r\n        await new Promise(r => setTimeout(r, 300));\r\n    } catch (e) {\r\n        // Ignore setting errors\r\n    }\r\n}\r\n\r\n// -----------------------------------------------------------------------------\r\n// HELPER: Silent Teleport (Aggressively Suppresses V13 Deprecation Warning)\r\n// -----------------------------------------------------------------------------\r\nasync function silentTeleport(token, pos) {\r\n    // CAPTURE ORIGINAL METHODS\r\n    const originalWarn = console.warn;\r\n    const originalError = console.error; // Sometimes deprecations log as errors\r\n\r\n    // DEFINING THE FILTER\r\n    // We filter any message that mentions the specific deprecated field.\r\n    const isPolluted = (...args) => {\r\n        const msg = args.map(a => {\r\n            if (a instanceof Error) return a.message;\r\n            return a?.toString() || '';\r\n        }).join(' ');\r\n        return msg.includes('DatabaseUpdateOperation#teleport');\r\n    };\r\n\r\n    // APPLY PATCHES\r\n    console.warn = function (...args) {\r\n        if (isPolluted(...args)) return;\r\n        originalWarn.apply(console, args);\r\n    };\r\n    console.error = function (...args) {\r\n        if (isPolluted(...args)) return;\r\n        originalError.apply(console, args);\r\n    };\r\n\r\n    try {\r\n        // EXECUTE TELEPORT\r\n        // 'teleport: true' is indeed the functionality we want.\r\n        await token.document.update(pos, {\r\n            animate: false,\r\n            animation: { duration: 0 },\r\n            teleport: true,\r\n            skippingMemory: true\r\n        });\r\n    } catch (err) {\r\n        // Allow genuine errors\r\n        originalError.apply(console, [\"Storyteller Cinema | Teleport Error:\", err]);\r\n    } finally {\r\n        // RESTORE CONSOLE\r\n        console.warn = originalWarn;\r\n        console.error = originalError;\r\n    }\r\n}\r\n\r\n\r\n// --- HELPER: CINEMATIC BACKGROUND ---\r\nlet cinematicContainer = null;\r\n\r\n// REAL IMPLEMENTATION OF `setCinematicBackground` with V13 Token Safety\r\nasync function setCinematicBackground(active) {\r\n    if (active) {\r\n        const bgPath = canvas.scene.getFlag('storyteller-cinema', 'cinematicBg');\r\n\r\n        // CRITICAL FIX: DO NOT HIDE canvas.primary (It contains Tokens in V13!)\r\n        // Instead, we try to hide the map specifically.\r\n        // canvas.primary.background is the likely candidate.\r\n        // canvas.primary.background is the likely candidate.\r\n        if (canvas.primary?.background) {\r\n            canvas.primary.background.visible = false;\r\n        }\r\n\r\n        // --- HIDE CLUTTER ---\r\n        if (canvas.grid) canvas.grid.visible = false;\r\n        if (canvas.walls) canvas.walls.visible = false;\r\n        if (canvas.templates) canvas.templates.visible = false;\r\n        if (canvas.foreground) canvas.foreground.visible = false; // Foreground tiles?\r\n\r\n        // Hide Door Icons (Controls Layer)\r\n        if (canvas.controls?.doors) canvas.controls.doors.visible = false;\r\n\r\n        if (bgPath) {\r\n            try {\r\n                const tex = await foundry.canvas.loadTexture(bgPath);\r\n                if (!tex) return;\r\n\r\n                // STALE CONTAINER CHECK\r\n                // If we changed scenes, cinematicContainer might be a leftover from the previous canvas.\r\n                // We must verify if it belongs to the CURRENT canvas.primary.\r\n                if (cinematicContainer) {\r\n                    if (cinematicContainer.destroyed || cinematicContainer.parent !== canvas.primary) {\r\n                        if (!cinematicContainer.destroyed) cinematicContainer.destroy({ children: true });\r\n                        cinematicContainer = null;\r\n                    }\r\n                }\r\n\r\n                if (!cinematicContainer) {\r\n                    cinematicContainer = new PIXI.Container();\r\n\r\n                    cinematicContainer.eventMode = 'none'; // Passive\r\n\r\n                    const sprite = new PIXI.Sprite(tex);\r\n                    sprite.anchor.set(0.5);\r\n                    cinematicContainer.addChild(sprite);\r\n\r\n                    // Insert BEHIND tokens.\r\n                    // We attach to canvas.primary but send to bottom (index 0).\r\n                    canvas.primary.addChildAt(cinematicContainer, 0);\r\n                }\r\n\r\n                const sprite = cinematicContainer.children[0];\r\n                sprite.texture = tex;\r\n\r\n                // --- CAMERA & SCALE LOGIC ---\r\n                // 1. Calculate Target Camera Scale (Fit Scene to Screen)\r\n                // We do this EARLY to determine how big the background needs to be to fill the screen.\r\n                const rect = canvas.dimensions.sceneRect;\r\n                const scaleW = window.innerWidth / rect.width;\r\n                const scaleH = window.innerHeight / rect.height;\r\n                const cameraScale = Math.min(scaleW, scaleH); // Removed margin for tighter fit\r\n\r\n                // 2. Calculate Visible World Area at that scale\r\n                const visibleWorldWidth = window.innerWidth / cameraScale;\r\n                const visibleWorldHeight = window.innerHeight / cameraScale;\r\n\r\n                // 3. Centralize Sprite to SCENE\r\n                const cx = rect.x + rect.width / 2;\r\n                const cy = rect.y + rect.height / 2;\r\n                sprite.position.set(cx, cy);\r\n\r\n                // 4. Scale Sprite to COVER the LARGER of (Scene, Visible Screen)\r\n                // This ensures \"Widescreen\" images fill the side bars if the map is square.\r\n                const targetWidth = Math.max(rect.width, visibleWorldWidth);\r\n                const targetHeight = Math.max(rect.height, visibleWorldHeight);\r\n\r\n                const texScaleX = targetWidth / tex.width;\r\n                const texScaleY = targetHeight / tex.height;\r\n                const finalScale = Math.max(texScaleX, texScaleY);\r\n\r\n                sprite.scale.set(finalScale);\r\n\r\n            } catch (err) {\r\n                console.error(\"Storyteller Cinema | BG Error:\", err);\r\n            }\r\n        }\r\n    } else {\r\n        // Restore\r\n        // SAFETY: Only enable visibility if there IS a background texture/image.\r\n        // Forcing visible=true on an empty background mesh crashes Foundry's collisionTest (#getTextureAlpha).\r\n        if (canvas.primary?.background) {\r\n            const hasBgImage = canvas.scene.background?.src;\r\n            const hasTexture = canvas.primary.background.texture;\r\n\r\n            // Only restore if valid. If no BG, Foundry keeps it handled/hidden naturally.\r\n            if (hasBgImage && hasTexture) {\r\n                canvas.primary.background.visible = true;\r\n            }\r\n        }\r\n\r\n        if (canvas.grid) canvas.grid.visible = true;\r\n\r\n        // --- RESTORE CLUTTER ---\r\n        if (canvas.walls) canvas.walls.visible = true;\r\n        if (canvas.templates) canvas.templates.visible = true;\r\n        if (canvas.foreground) canvas.foreground.visible = true;\r\n        if (canvas.controls?.doors) canvas.controls.doors.visible = true;\r\n\r\n        if (cinematicContainer) {\r\n            cinematicContainer.destroy({ children: true, texture: false });\r\n            cinematicContainer = null;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// --- EXPORTED TOGGLE ---\r\n\r\nexport async function toggleCinematicMode(active, options = {}) {\r\n    console.log(\"Storyteller Cinema | Toggle Called. Target:\", active);\r\n    const overlay = document.getElementById('storyteller-cinema-overlay');\r\n\r\n    if (active) {\r\n        // --- 1. ATIVAR ---\r\n\r\n        // SAVE BATTLE VIEW\r\n        const battleView = {\r\n            x: canvas.stage.pivot.x,\r\n            y: canvas.stage.pivot.y,\r\n            scale: canvas.stage.scale.x\r\n        };\r\n        // Store in a module-level variable or flag? Flag is safer for reload, but var is okay for temporary toggle.\r\n        // Let's use a temporary flag on the canvas object itself to avoid cluttering DB\r\n        canvas.storytellerBattleView = battleView;\r\n\r\n        // Cinematic Mode: Enable Ghost Mode (No Walls / Free Movement)\r\n        await ensureGhostMode(true);\r\n        await setCinematicBackground(true);\r\n\r\n        if (overlay) overlay.classList.add('active');\r\n        document.body.classList.add('cinematic-mode');\r\n\r\n        // PAN TO FIT SCREEN (Optimal Cinematic View)\r\n        // 1. Calculate Target Camera Scale (Fit Scene to Screen)\r\n        const rect = canvas.dimensions.sceneRect;\r\n        const scaleW = window.innerWidth / rect.width;\r\n        const scaleH = window.innerHeight / rect.height;\r\n        // CHANGE: Use Math.max (COVER behavior) to ensure NO BLACK BARS.\r\n        // This means we might crop the top/bottom or sides of the scene, but the screen will be full.\r\n        // This respects the \"Widescreen\" request.\r\n        let targetScale = Math.max(scaleW, scaleH);\r\n\r\n        // CRITICAL FIX: Foundry clamps zoom options.\r\n        // We must calculate the sprite coverage based on the ACTUAL resulting zoom.\r\n        const minZ = canvas.minScale || 0.1;\r\n        const maxZ = canvas.maxScale || 3.0;\r\n        targetScale = Math.max(minZ, Math.min(maxZ, targetScale));\r\n\r\n        const cx = rect.x + rect.width / 2;\r\n        const cy = rect.y + rect.height / 2;\r\n\r\n        await canvas.animatePan({ x: cx, y: cy, scale: targetScale, duration: 800 });\r\n\r\n        // Update Background Sprite AFTER calculating the final scale logic\r\n        // We need to ensure it covers the visible area at THIS scale.\r\n        if (cinematicContainer && cinematicContainer.children[0]) {\r\n            const sprite = cinematicContainer.children[0];\r\n            const tex = sprite.texture;\r\n\r\n            // Re-calc visible area based on the CLAMPED scale\r\n            const visibleWorldWidth = window.innerWidth / targetScale;\r\n            const visibleWorldHeight = window.innerHeight / targetScale;\r\n\r\n            // Ensure position is correct\r\n            sprite.position.set(cx, cy);\r\n\r\n            const targetWidth = Math.max(rect.width, visibleWorldWidth);\r\n            const targetHeight = Math.max(rect.height, visibleWorldHeight);\r\n\r\n            const texScaleX = targetWidth / tex.width;\r\n            const texScaleY = targetHeight / tex.height;\r\n            const finalScale = Math.max(texScaleX, texScaleY);\r\n\r\n            sprite.scale.set(finalScale);\r\n        }\r\n\r\n\r\n        if (canvas.tokens) {\r\n            for (const token of canvas.tokens.placeables) {\r\n                // ... (Token Logic Stays Same)\r\n                // Read-Only Battle Save\r\n                const existingBattlePos = token.document.getFlag('storyteller-cinema', 'battlePos');\r\n                if (!existingBattlePos) {\r\n                    const currentPos = { x: token.document.x, y: token.document.y };\r\n                    await token.document.setFlag('storyteller-cinema', 'battlePos', currentPos);\r\n                }\r\n\r\n                // --- VISUAL CLEANUP: HIDE BEFORE OP ---\r\n                if (token.mesh) token.mesh.alpha = 0;\r\n\r\n                const updates = {};\r\n                const cinPos = token.document.getFlag('storyteller-cinema', 'cinematicPos');\r\n                if (cinPos) {\r\n                    updates.x = cinPos.x;\r\n                    updates.y = cinPos.y;\r\n                }\r\n\r\n                // --- CINEMATIC TEXTURE SWAP ---\r\n                const cinTexture = token.document.getFlag('storyteller-cinema', 'cinematicTexture');\r\n                if (cinTexture) {\r\n                    // SAFETY: Only save original if NOT already saved (prevents overwriting with cinematic texture if stuck)\r\n                    const existingOriginal = token.document.getFlag('storyteller-cinema', 'originalTexture');\r\n                    if (!existingOriginal) {\r\n                        await token.document.setFlag('storyteller-cinema', 'originalTexture', token.document.texture.src);\r\n                    }\r\n\r\n                    // Preload Texture\r\n                    try { await foundry.canvas.loadTexture(cinTexture); } catch (e) { }\r\n\r\n                    // Add to updates\r\n                    updates[\"texture.src\"] = cinTexture;\r\n                }\r\n\r\n                // EXECUTE SINGLE ATOMIC UPDATE\r\n                if (Object.keys(updates).length > 0) {\r\n                    await silentTeleport(token, updates);\r\n                }\r\n\r\n                applyVisualDepth(token);\r\n\r\n                // --- REVEAL ---\r\n                if (token.mesh) {\r\n                    // Simple fade in using V13 API\r\n                    const CanvasAnimation = foundry.canvas.animation.CanvasAnimation;\r\n                    CanvasAnimation.animate([{ parent: token.mesh, attribute: \"alpha\", to: 1 }], { duration: 400, name: `FadeIn-${token.id}` });\r\n                }\r\n            }\r\n        }\r\n\r\n    } else {\r\n        // --- 2. DESATIVAR ---\r\n        // Battle Mode: Disable Ghost Mode (Walls Active / Constrained)\r\n        await ensureGhostMode(false, true);\r\n        await setCinematicBackground(false);\r\n\r\n        if (overlay) overlay.classList.remove('active');\r\n        document.body.classList.remove('cinematic-mode');\r\n\r\n        // RESTORE BATTLE VIEW\r\n        if (canvas.storytellerBattleView) {\r\n            const v = canvas.storytellerBattleView;\r\n            await canvas.animatePan({ x: v.x, y: v.y, scale: v.scale, duration: 800 });\r\n            canvas.storytellerBattleView = null;\r\n        }\r\n\r\n        if (canvas.tokens) {\r\n            // ... (Token Logic Stays Same)\r\n            for (const token of canvas.tokens.placeables) {\r\n                if (token.document) {\r\n                    const currentPos = { x: token.document.x, y: token.document.y };\r\n                    await token.document.setFlag('storyteller-cinema', 'cinematicPos', currentPos);\r\n\r\n                    const battlePos = token.document.getFlag('storyteller-cinema', 'battlePos');\r\n\r\n                    if (token.mesh) {\r\n                        // Fade out before revert\r\n                        token.mesh.alpha = 0;\r\n                    }\r\n\r\n                    const updates = {};\r\n\r\n                    // --- CINEMATIC TEXTURE RESTORE ---\r\n                    const originalTexture = token.document.getFlag('storyteller-cinema', 'originalTexture');\r\n                    if (originalTexture) {\r\n                        try { await foundry.canvas.loadTexture(originalTexture); } catch (e) { }\r\n                        updates[\"texture.src\"] = originalTexture;\r\n                        await token.document.unsetFlag('storyteller-cinema', 'originalTexture');\r\n                    }\r\n\r\n                    if (battlePos) {\r\n                        updates.x = battlePos.x;\r\n                        updates.y = battlePos.y;\r\n                    }\r\n\r\n                    // EXECUTE SINGLE ATOMIC UPDATE\r\n                    if (Object.keys(updates).length > 0) {\r\n                        await silentTeleport(token, updates);\r\n                    }\r\n\r\n                    if (token.mesh) {\r\n                        token.mesh.scale.set(token.document.texture.scaleX, token.document.texture.scaleY);\r\n                        // Restore visibility based on hidden state\r\n                        const targetAlpha = token.document.hidden ? 0.5 : 1;\r\n                        const CanvasAnimation = foundry.canvas.animation.CanvasAnimation;\r\n                        CanvasAnimation.animate([{ parent: token.mesh, attribute: \"alpha\", to: targetAlpha }], { duration: 400, name: `FadeOut-${token.id}` });\r\n                        token.refresh();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n"],"names":["sprite"],"mappings":"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"}
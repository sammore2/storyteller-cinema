{"version":3,"file":"cinematic.js","sources":["../../src/scripts/core/cinematic.js"],"sourcesContent":["// import { applyVisualDepth } from './depth.js';\r\n\r\nexport function createOverlay() {\r\n    if (document.getElementById('storyteller-cinema-overlay')) return;\r\n    const overlay = document.createElement('div');\r\n    overlay.id = 'storyteller-cinema-overlay';\r\n    overlay.innerHTML = '<div class=\"cinematic-bar top\"></div><div class=\"cinematic-bar bottom\"></div>';\r\n    document.body.appendChild(overlay);\r\n}\r\n\r\n// -----------------------------------------------------------------------------\r\n// HELPER: Wait for Ghost Mode \r\n// -----------------------------------------------------------------------------\r\nasync function ensureGhostMode(targetState, force = false) {\r\n    const currentState = game.settings.get(\"core\", \"unconstrainedMovement\");\r\n    if (currentState === targetState && !force) return;\r\n    try {\r\n        await game.settings.set(\"core\", \"unconstrainedMovement\", targetState);\r\n        await new Promise(r => setTimeout(r, 300));\r\n    } catch (e) {\r\n        // Ignore setting errors\r\n    }\r\n}\r\n\r\n// -----------------------------------------------------------------------------\r\n// HELPER: Silent Teleport (Aggressively Suppresses V13 Deprecation Warning)\r\n// -----------------------------------------------------------------------------\r\nasync function silentTeleport(token, pos) {\r\n    // CAPTURE ORIGINAL METHODS\r\n    const originalWarn = console.warn;\r\n    const originalError = console.error; // Sometimes deprecations log as errors\r\n\r\n    // DEFINING THE FILTER\r\n    // We filter any message that mentions the specific deprecated field.\r\n    const isPolluted = (...args) => {\r\n        const msg = args.map(a => {\r\n            if (a instanceof Error) return a.message;\r\n            return a?.toString() || '';\r\n        }).join(' ');\r\n        return msg.includes('DatabaseUpdateOperation#teleport');\r\n    };\r\n\r\n    // APPLY PATCHES\r\n    console.warn = function (...args) {\r\n        if (isPolluted(...args)) return;\r\n        originalWarn.apply(console, args);\r\n    };\r\n    console.error = function (...args) {\r\n        if (isPolluted(...args)) return;\r\n        originalError.apply(console, args);\r\n    };\r\n\r\n    try {\r\n        // EXECUTE TELEPORT\r\n        // 'teleport: true' is indeed the functionality we want.\r\n        await token.document.update(pos, {\r\n            animate: false,\r\n            animation: { duration: 0 },\r\n            teleport: true,\r\n            skippingMemory: true\r\n        });\r\n    } catch (err) {\r\n        // Allow genuine errors\r\n        originalError.apply(console, [\"Storyteller Cinema | Teleport Error:\", err]);\r\n    } finally {\r\n        // RESTORE CONSOLE\r\n        console.warn = originalWarn;\r\n        console.error = originalError;\r\n    }\r\n}\r\n\r\n\r\n// --- HELPER: CINEMATIC BACKGROUND ---\r\nlet cinematicContainer = null;\r\n\r\nHooks.on('canvasReady', () => {\r\n    const viewMode = canvas.scene.getFlag('storyteller-cinema', 'viewMode');\r\n    // PERSISTENCE: Check if it's currently active in DB\r\n    const isActive = canvas.scene.getFlag('storyteller-cinema', 'active') || false;\r\n\r\n    // Check if cinematic is mandated by flag or legacy viewMode\r\n    const shouldBeCinematic = isActive || viewMode === 'cinematic';\r\n\r\n    // Use 'default' skin or fetch from flag if we had one (simplified for now)\r\n    // The new signature is (active, skin). We won't pass object options anymore.\r\n    toggleCinematicMode(shouldBeCinematic, 'default');\r\n});\r\n\r\n// REAL IMPLEMENTATION OF `setCinematicBackground` with V13 Token Safety\r\nasync function setCinematicBackground(active) {\r\n    if (active) {\r\n        const bgPath = canvas.scene.getFlag('storyteller-cinema', 'cinematicBg');\r\n        console.log(\"Storyteller Cinema | ðŸ–¼ï¸ Setting Background. Path:\", bgPath);\r\n\r\n        // --- HIDE CLUTTER ---\r\n        // CRITICAL FIX: DO NOT HIDE canvas.primary (It contains Tokens in V13!)\r\n        if (canvas.primary?.background) {\r\n            canvas.primary.background.visible = false;\r\n        }\r\n\r\n        if (canvas.grid) canvas.grid.visible = false;\r\n        if (canvas.walls) canvas.walls.visible = false;\r\n        if (canvas.templates) canvas.templates.visible = false;\r\n        if (canvas.foreground) canvas.foreground.visible = false;\r\n\r\n        if (canvas.controls?.doors) canvas.controls.doors.visible = false;\r\n\r\n        // --- HIDE LIGHTING & ATMOSPHERE ---\r\n        if (canvas.lighting) canvas.lighting.visible = false;\r\n        if (canvas.effects) canvas.effects.visible = false;\r\n        if (canvas.fog) canvas.fog.visible = false;\r\n\r\n        if (bgPath) {\r\n            try {\r\n                const tex = await foundry.canvas.loadTexture(bgPath);\r\n\r\n                // STALE CONTAINER CHECK\r\n                if (cinematicContainer) {\r\n                    if (cinematicContainer.destroyed || cinematicContainer.parent !== canvas.primary) {\r\n                        if (!cinematicContainer.destroyed) cinematicContainer.destroy({ children: true });\r\n                        cinematicContainer = null;\r\n                    }\r\n                }\r\n\r\n                if (!cinematicContainer) {\r\n                    cinematicContainer = new PIXI.Container();\r\n                    cinematicContainer.eventMode = 'none'; // Passive\r\n\r\n                    const sprite = new PIXI.Sprite(tex);\r\n                    sprite.anchor.set(0.5);\r\n                    cinematicContainer.addChild(sprite);\r\n\r\n                    // Insert BEHIND tokens (index 0 of primary)\r\n                    canvas.primary.addChildAt(cinematicContainer, 0);\r\n                }\r\n\r\n                const sprite = cinematicContainer.children[0];\r\n                sprite.texture = tex;\r\n\r\n                // --- CAMERA & SCALE LOGIC ---\r\n                // 1. Calculate Target Camera Scale (Fit Scene to Screen)\r\n                // We do this EARLY to determine how big the background needs to be to fill the screen.\r\n                const rect = canvas.dimensions.sceneRect;\r\n                const scaleW = window.innerWidth / rect.width;\r\n                const scaleH = window.innerHeight / rect.height;\r\n                const cameraScale = Math.min(scaleW, scaleH); // Removed margin for tighter fit\r\n\r\n                // 2. Calculate Visible World Area at that scale\r\n                const visibleWorldWidth = window.innerWidth / cameraScale;\r\n                const visibleWorldHeight = window.innerHeight / cameraScale;\r\n\r\n                // 3. Centralize Sprite to SCENE\r\n                const cx = rect.x + rect.width / 2;\r\n                const cy = rect.y + rect.height / 2;\r\n                sprite.position.set(cx, cy);\r\n\r\n                // 4. Scale Sprite to COVER the LARGER of (Scene, Visible Screen)\r\n                // This ensures \"Widescreen\" images fill the side bars if the map is square.\r\n                const targetWidth = Math.max(rect.width, visibleWorldWidth);\r\n                const targetHeight = Math.max(rect.height, visibleWorldHeight);\r\n\r\n                const texScaleX = targetWidth / tex.width;\r\n                const texScaleY = targetHeight / tex.height;\r\n                const finalScale = Math.max(texScaleX, texScaleY);\r\n\r\n                sprite.scale.set(finalScale);\r\n\r\n            } catch (err) {\r\n                console.error(\"Storyteller Cinema | BG Error:\", err);\r\n            }\r\n        }\r\n\r\n    } else {\r\n        // Restore\r\n        // SAFETY: Only enable visibility if there IS a background texture/image.\r\n        // Forcing visible=true on an empty background mesh crashes Foundry's collisionTest (#getTextureAlpha).\r\n        if (canvas.primary?.background) {\r\n            const hasBgImage = canvas.scene.background?.src;\r\n            const hasTexture = canvas.primary.background.texture;\r\n\r\n            // Only restore if valid. If no BG, Foundry keeps it handled/hidden naturally.\r\n            if (hasBgImage && hasTexture) {\r\n                canvas.primary.background.visible = true;\r\n            }\r\n        }\r\n\r\n        if (canvas.grid) canvas.grid.visible = true;\r\n\r\n        // --- RESTORE CLUTTER ---\r\n        if (canvas.walls) canvas.walls.visible = true;\r\n        if (canvas.templates) canvas.templates.visible = true;\r\n        if (canvas.foreground) canvas.foreground.visible = true;\r\n        if (canvas.controls?.doors) canvas.controls.doors.visible = true;\r\n\r\n        // --- RESTORE LIGHTING & ATMOSPHERE ---\r\n        if (canvas.lighting) canvas.lighting.visible = true;\r\n        if (canvas.effects) canvas.effects.visible = true;\r\n        if (canvas.fog) canvas.fog.visible = true;\r\n\r\n        if (cinematicContainer) {\r\n            cinematicContainer.destroy({ children: true, texture: false });\r\n            cinematicContainer = null;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// VariÃ¡vel externa Ã  funÃ§Ã£o para guardar o estado anterior da visÃ£o\r\nlet _visionCache = true;\r\n\r\nexport function toggleCinematicMode(active, skin = 'default') {\r\n    const body = document.body;\r\n\r\n    if (active) {\r\n        // 1. Aplica o CSS (Visual da Interface)\r\n        body.classList.add('cinematic-mode');\r\n        if (skin !== 'default') {\r\n            body.classList.add(`cinematic-skin-${skin}`);\r\n        }\r\n\r\n        // 2. Desliga a NÃ©voa de Guerra (Visual do Canvas)\r\n        // Isso faz com que o mapa seja visÃ­vel sem precisar de luzes ou tokens\r\n        if (canvas.ready) {\r\n            _visionCache = canvas.sight.tokenVision; // Salva como estava (geralmente true)\r\n            canvas.sight.tokenVision = false;        // Desliga a restriÃ§Ã£o\r\n            canvas.perception.refresh();             // Atualiza a renderizaÃ§Ã£o\r\n        }\r\n\r\n    } else {\r\n        // 1. Remove o CSS\r\n        body.classList.remove('cinematic-mode');\r\n\r\n        // Limpa classes de skins antigas\r\n        const skinClasses = Array.from(body.classList).filter(c => c.startsWith('cinematic-skin-'));\r\n        skinClasses.forEach(c => body.classList.remove(c));\r\n\r\n        // 2. Restaura a NÃ©voa de Guerra\r\n        if (canvas.ready) {\r\n            canvas.sight.tokenVision = _visionCache; // Devolve o valor original\r\n            canvas.perception.refresh();             // Atualiza a renderizaÃ§Ã£o\r\n        }\r\n    }\r\n}\r\n\r\n// --- AUTO-REFRESH ON SETTINGS CHANGE ---\r\nHooks.on('updateScene', (document, change, options, userId) => {\r\n    if (!document.isView) return; // Only if it's the current scene\r\n\r\n    // 1. Check for ACTIVATION Toggle\r\n    const activeChange = change.flags?.['storyteller-cinema']?.active;\r\n    if (activeChange !== undefined) {\r\n        toggleCinematicMode(activeChange);\r\n    }\r\n\r\n    // 2. Refresh Background if already active\r\n    if (window.document.body.classList.contains('cinematic-mode')) {\r\n        const flagChange = change.flags?.['storyteller-cinema']?.cinematicBg;\r\n        if (flagChange !== undefined) {\r\n            console.log(\"Storyteller Cinema | Background updated, refreshing...\");\r\n            setCinematicBackground(true);\r\n        }\r\n    }\r\n});\r\n"],"names":["sprite","document"],"mappings":"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"}
{"version":3,"file":"depth.js","sources":["../../src/scripts/core/depth.js"],"sourcesContent":["/**\n * Aplica escala visual híbrida (Auto Viewport + Manual Config + Quick Zoom).\n */\nexport function applyVisualDepth(token) {\n  if (!token.mesh || !token.scene) return;\n\n  // --- 1. Math: Viewport Target (Auto Scale) ---\n  const screenHeight = canvas.app.renderer.screen.height;\n  const refHeightPercent = game.settings.get('storyteller-cinema', 'referenceHeight') || 30;\n\n  // Altura alvo na tela em pixels\n  const targetPx = screenHeight * (refHeightPercent / 100);\n\n  // Altura da textura original\n  const texHeight = token.document.texture.src ? (token.texture?.height || 100) : 100;\n\n  // Escala automática para atingir o targetPx\n  const autoScale = targetPx / texHeight;\n\n  // --- 2. Manual Adjustments (User Control) ---\n\n  // Grid Size: Tokens grandes (2x2) devem ser maiores\n  const gridSizeMult = Math.max(token.document.width, token.document.height);\n\n  // Manual Scale: Respeita o slider \"Scale\" da ficha do token (Ajuste Permanente)\n  const docScaleX = token.document.texture.scaleX;\n  const manualTweak = Math.abs(docScaleX) || 1;\n\n  // --- NOVO: Cinematic Scale (Shift + Scroll - Ajuste Temporário/Rápido) ---\n  // Prioriza o preview local (instantâneo) sobre o dado do banco (lento)\n  const quickZoom = token._cinemaScalePreview ?? token.document.getFlag('storyteller-cinema', 'cinematicScale') ?? 1.0;\n\n  // Combina todos os multiplicadores manuais\n  const manualMultiplier = gridSizeMult * manualTweak * quickZoom;\n\n  // --- 3. Depth Factor (Parallax) ---\n  const sceneHeight = token.scene.dimensions.height;\n  let ratio = token.y / sceneHeight;\n  ratio = Math.max(0, Math.min(1, ratio));\n\n  const minDepth = game.settings.get('storyteller-cinema', 'minScale') || 0.5;\n  const maxDepth = game.settings.get('storyteller-cinema', 'maxScale') || 1.0;\n\n  const depthFactor = minDepth + (ratio * (maxDepth - minDepth));\n\n  // --- 4. Final Calculation ---\n  // Agora inclui o quickZoom na conta!\n  const finalScale = autoScale * manualMultiplier * depthFactor;\n\n  // --- 5. Application with Flip Preservation ---\n  if (Number.isFinite(finalScale)) {\n    // Detecta Flip Horizontal do Documento\n    const sign = Math.sign(docScaleX) || 1;\n\n    token.mesh.scale.set(finalScale * sign, finalScale);\n\n    // Trava Rotação Visual (Sempre em pé)\n    token.mesh.rotation = 0;\n  }\n}\n"],"names":[],"mappings":"AAGO,SAAS,iBAAiB,OAAO;AAHxC;AAIE,MAAI,CAAC,MAAM,QAAQ,CAAC,MAAM,MAAO;AAGjC,QAAM,eAAe,OAAO,IAAI,SAAS,OAAO;AAChD,QAAM,mBAAmB,KAAK,SAAS,IAAI,sBAAsB,iBAAiB,KAAK;AAGvF,QAAM,WAAW,gBAAgB,mBAAmB;AAGpD,QAAM,YAAY,MAAM,SAAS,QAAQ,QAAO,WAAM,YAAN,mBAAe,WAAU,MAAO;AAGhF,QAAM,YAAY,WAAW;AAK7B,QAAM,eAAe,KAAK,IAAI,MAAM,SAAS,OAAO,MAAM,SAAS,MAAM;AAGzE,QAAM,YAAY,MAAM,SAAS,QAAQ;AACzC,QAAM,cAAc,KAAK,IAAI,SAAS,KAAK;AAI3C,QAAM,YAAY,MAAM,uBAAuB,MAAM,SAAS,QAAQ,sBAAsB,gBAAgB,KAAK;AAGjH,QAAM,mBAAmB,eAAe,cAAc;AAGtD,QAAM,cAAc,MAAM,MAAM,WAAW;AAC3C,MAAI,QAAQ,MAAM,IAAI;AACtB,UAAQ,KAAK,IAAI,GAAG,KAAK,IAAI,GAAG,KAAK,CAAC;AAEtC,QAAM,WAAW,KAAK,SAAS,IAAI,sBAAsB,UAAU,KAAK;AACxE,QAAM,WAAW,KAAK,SAAS,IAAI,sBAAsB,UAAU,KAAK;AAExE,QAAM,cAAc,WAAY,SAAS,WAAW;AAIpD,QAAM,aAAa,YAAY,mBAAmB;AAGlD,MAAI,OAAO,SAAS,UAAU,GAAG;AAE/B,UAAM,OAAO,KAAK,KAAK,SAAS,KAAK;AAErC,UAAM,KAAK,MAAM,IAAI,aAAa,MAAM,UAAU;AAGlD,UAAM,KAAK,WAAW;AAAA,EACxB;AACF;"}
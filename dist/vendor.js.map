{"version":3,"file":"vendor.js","sources":["../node_modules/svelte/src/runtime/internal/utils.js","../node_modules/svelte/src/runtime/internal/dom.js","../node_modules/svelte/src/runtime/internal/lifecycle.js","../node_modules/svelte/src/runtime/internal/scheduler.js","../node_modules/svelte/src/runtime/internal/transitions.js","../node_modules/svelte/src/runtime/internal/Component.js","../node_modules/svelte/src/shared/version.js","../node_modules/svelte/src/runtime/internal/disclose-version/index.js"],"sourcesContent":["/** @returns {void} */\r\nexport function noop() {}\r\n\r\nexport const identity = (x) => x;\r\n\r\n/**\r\n * @template T\r\n * @template S\r\n * @param {T} tar\r\n * @param {S} src\r\n * @returns {T & S}\r\n */\r\nexport function assign(tar, src) {\r\n\t// @ts-ignore\r\n\tfor (const k in src) tar[k] = src[k];\r\n\treturn /** @type {T & S} */ (tar);\r\n}\r\n\r\n// Adapted from https://github.com/then/is-promise/blob/master/index.js\r\n// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE\r\n/**\r\n * @param {any} value\r\n * @returns {value is PromiseLike<any>}\r\n */\r\nexport function is_promise(value) {\r\n\treturn (\r\n\t\t!!value &&\r\n\t\t(typeof value === 'object' || typeof value === 'function') &&\r\n\t\ttypeof (/** @type {any} */ (value).then) === 'function'\r\n\t);\r\n}\r\n\r\n/** @returns {void} */\r\nexport function add_location(element, file, line, column, char) {\r\n\telement.__svelte_meta = {\r\n\t\tloc: { file, line, column, char }\r\n\t};\r\n}\r\n\r\nexport function run(fn) {\r\n\treturn fn();\r\n}\r\n\r\nexport function blank_object() {\r\n\treturn Object.create(null);\r\n}\r\n\r\n/**\r\n * @param {Function[]} fns\r\n * @returns {void}\r\n */\r\nexport function run_all(fns) {\r\n\tfns.forEach(run);\r\n}\r\n\r\n/**\r\n * @param {any} thing\r\n * @returns {thing is Function}\r\n */\r\nexport function is_function(thing) {\r\n\treturn typeof thing === 'function';\r\n}\r\n\r\n/** @returns {boolean} */\r\nexport function safe_not_equal(a, b) {\r\n\treturn a != a ? b == b : a !== b || (a && typeof a === 'object') || typeof a === 'function';\r\n}\r\n\r\nlet src_url_equal_anchor;\r\n\r\n/**\r\n * @param {string} element_src\r\n * @param {string} url\r\n * @returns {boolean}\r\n */\r\nexport function src_url_equal(element_src, url) {\r\n\tif (element_src === url) return true;\r\n\tif (!src_url_equal_anchor) {\r\n\t\tsrc_url_equal_anchor = document.createElement('a');\r\n\t}\r\n\t// This is actually faster than doing URL(..).href\r\n\tsrc_url_equal_anchor.href = url;\r\n\treturn element_src === src_url_equal_anchor.href;\r\n}\r\n\r\n/** @param {string} srcset */\r\nfunction split_srcset(srcset) {\r\n\treturn srcset.split(',').map((src) => src.trim().split(' ').filter(Boolean));\r\n}\r\n\r\n/**\r\n * @param {HTMLSourceElement | HTMLImageElement} element_srcset\r\n * @param {string | undefined | null} srcset\r\n * @returns {boolean}\r\n */\r\nexport function srcset_url_equal(element_srcset, srcset) {\r\n\tconst element_urls = split_srcset(element_srcset.srcset);\r\n\tconst urls = split_srcset(srcset || '');\r\n\r\n\treturn (\r\n\t\turls.length === element_urls.length &&\r\n\t\turls.every(\r\n\t\t\t([url, width], i) =>\r\n\t\t\t\twidth === element_urls[i][1] &&\r\n\t\t\t\t// We need to test both ways because Vite will create an a full URL with\r\n\t\t\t\t// `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the\r\n\t\t\t\t// relative URLs inside srcset are not automatically resolved to absolute URLs by\r\n\t\t\t\t// browsers (in contrast to img.src). This means both SSR and DOM code could\r\n\t\t\t\t// contain relative or absolute URLs.\r\n\t\t\t\t(src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0]))\r\n\t\t)\r\n\t);\r\n}\r\n\r\n/** @returns {boolean} */\r\nexport function not_equal(a, b) {\r\n\treturn a != a ? b == b : a !== b;\r\n}\r\n\r\n/** @returns {boolean} */\r\nexport function is_empty(obj) {\r\n\treturn Object.keys(obj).length === 0;\r\n}\r\n\r\n/** @returns {void} */\r\nexport function validate_store(store, name) {\r\n\tif (store != null && typeof store.subscribe !== 'function') {\r\n\t\tthrow new Error(`'${name}' is not a store with a 'subscribe' method`);\r\n\t}\r\n}\r\n\r\nexport function subscribe(store, ...callbacks) {\r\n\tif (store == null) {\r\n\t\tfor (const callback of callbacks) {\r\n\t\t\tcallback(undefined);\r\n\t\t}\r\n\t\treturn noop;\r\n\t}\r\n\tconst unsub = store.subscribe(...callbacks);\r\n\treturn unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\r\n}\r\n\r\n/**\r\n * Get the current value from a store by subscribing and immediately unsubscribing.\r\n *\r\n * https://svelte.dev/docs/svelte-store#get\r\n * @template T\r\n * @param {import('../store/public.js').Readable<T>} store\r\n * @returns {T}\r\n */\r\nexport function get_store_value(store) {\r\n\tlet value;\r\n\tsubscribe(store, (_) => (value = _))();\r\n\treturn value;\r\n}\r\n\r\n/** @returns {void} */\r\nexport function component_subscribe(component, store, callback) {\r\n\tcomponent.$$.on_destroy.push(subscribe(store, callback));\r\n}\r\n\r\nexport function create_slot(definition, ctx, $$scope, fn) {\r\n\tif (definition) {\r\n\t\tconst slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\r\n\t\treturn definition[0](slot_ctx);\r\n\t}\r\n}\r\n\r\nfunction get_slot_context(definition, ctx, $$scope, fn) {\r\n\treturn definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\r\n}\r\n\r\nexport function get_slot_changes(definition, $$scope, dirty, fn) {\r\n\tif (definition[2] && fn) {\r\n\t\tconst lets = definition[2](fn(dirty));\r\n\t\tif ($$scope.dirty === undefined) {\r\n\t\t\treturn lets;\r\n\t\t}\r\n\t\tif (typeof lets === 'object') {\r\n\t\t\tconst merged = [];\r\n\t\t\tconst len = Math.max($$scope.dirty.length, lets.length);\r\n\t\t\tfor (let i = 0; i < len; i += 1) {\r\n\t\t\t\tmerged[i] = $$scope.dirty[i] | lets[i];\r\n\t\t\t}\r\n\t\t\treturn merged;\r\n\t\t}\r\n\t\treturn $$scope.dirty | lets;\r\n\t}\r\n\treturn $$scope.dirty;\r\n}\r\n\r\n/** @returns {void} */\r\nexport function update_slot_base(\r\n\tslot,\r\n\tslot_definition,\r\n\tctx,\r\n\t$$scope,\r\n\tslot_changes,\r\n\tget_slot_context_fn\r\n) {\r\n\tif (slot_changes) {\r\n\t\tconst slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\r\n\t\tslot.p(slot_context, slot_changes);\r\n\t}\r\n}\r\n\r\n/** @returns {void} */\r\nexport function update_slot(\r\n\tslot,\r\n\tslot_definition,\r\n\tctx,\r\n\t$$scope,\r\n\tdirty,\r\n\tget_slot_changes_fn,\r\n\tget_slot_context_fn\r\n) {\r\n\tconst slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\r\n\tupdate_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\r\n}\r\n\r\n/** @returns {any[] | -1} */\r\nexport function get_all_dirty_from_scope($$scope) {\r\n\tif ($$scope.ctx.length > 32) {\r\n\t\tconst dirty = [];\r\n\t\tconst length = $$scope.ctx.length / 32;\r\n\t\tfor (let i = 0; i < length; i++) {\r\n\t\t\tdirty[i] = -1;\r\n\t\t}\r\n\t\treturn dirty;\r\n\t}\r\n\treturn -1;\r\n}\r\n\r\n/** @returns {{}} */\r\nexport function exclude_internal_props(props) {\r\n\tconst result = {};\r\n\tfor (const k in props) if (k[0] !== '$') result[k] = props[k];\r\n\treturn result;\r\n}\r\n\r\n/** @returns {{}} */\r\nexport function compute_rest_props(props, keys) {\r\n\tconst rest = {};\r\n\tkeys = new Set(keys);\r\n\tfor (const k in props) if (!keys.has(k) && k[0] !== '$') rest[k] = props[k];\r\n\treturn rest;\r\n}\r\n\r\n/** @returns {{}} */\r\nexport function compute_slots(slots) {\r\n\tconst result = {};\r\n\tfor (const key in slots) {\r\n\t\tresult[key] = true;\r\n\t}\r\n\treturn result;\r\n}\r\n\r\n/** @returns {(this: any, ...args: any[]) => void} */\r\nexport function once(fn) {\r\n\tlet ran = false;\r\n\treturn function (...args) {\r\n\t\tif (ran) return;\r\n\t\tran = true;\r\n\t\tfn.call(this, ...args);\r\n\t};\r\n}\r\n\r\nexport function null_to_empty(value) {\r\n\treturn value == null ? '' : value;\r\n}\r\n\r\nexport function set_store_value(store, ret, value) {\r\n\tstore.set(value);\r\n\treturn ret;\r\n}\r\n\r\nexport const has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\r\n\r\nexport function action_destroyer(action_result) {\r\n\treturn action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\r\n}\r\n\r\n/** @param {number | string} value\r\n * @returns {[number, string]}\r\n */\r\nexport function split_css_unit(value) {\r\n\tconst split = typeof value === 'string' && value.match(/^\\s*(-?[\\d.]+)([^\\s]*)\\s*$/);\r\n\treturn split ? [parseFloat(split[1]), split[2] || 'px'] : [/** @type {number} */ (value), 'px'];\r\n}\r\n\r\nexport const contenteditable_truthy_values = ['', true, 1, 'true', 'contenteditable'];\r\n","import { contenteditable_truthy_values, has_prop } from './utils.js';\r\n\r\nimport { ResizeObserverSingleton } from './ResizeObserverSingleton.js';\r\n\r\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\r\n// at the end of hydration without touching the remaining nodes.\r\nlet is_hydrating = false;\r\n\r\n/**\r\n * @returns {void}\r\n */\r\nexport function start_hydrating() {\r\n\tis_hydrating = true;\r\n}\r\n\r\n/**\r\n * @returns {void}\r\n */\r\nexport function end_hydrating() {\r\n\tis_hydrating = false;\r\n}\r\n\r\n/**\r\n * @param {number} low\r\n * @param {number} high\r\n * @param {(index: number) => number} key\r\n * @param {number} value\r\n * @returns {number}\r\n */\r\nfunction upper_bound(low, high, key, value) {\r\n\t// Return first index of value larger than input value in the range [low, high)\r\n\twhile (low < high) {\r\n\t\tconst mid = low + ((high - low) >> 1);\r\n\t\tif (key(mid) <= value) {\r\n\t\t\tlow = mid + 1;\r\n\t\t} else {\r\n\t\t\thigh = mid;\r\n\t\t}\r\n\t}\r\n\treturn low;\r\n}\r\n\r\n/**\r\n * @param {NodeEx} target\r\n * @returns {void}\r\n */\r\nfunction init_hydrate(target) {\r\n\tif (target.hydrate_init) return;\r\n\ttarget.hydrate_init = true;\r\n\t// We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\r\n\r\n\tlet children = /** @type {ArrayLike<NodeEx2>} */ (target.childNodes);\r\n\t// If target is <head>, there may be children without claim_order\r\n\tif (target.nodeName === 'HEAD') {\r\n\t\tconst my_children = [];\r\n\t\tfor (let i = 0; i < children.length; i++) {\r\n\t\t\tconst node = children[i];\r\n\t\t\tif (node.claim_order !== undefined) {\r\n\t\t\t\tmy_children.push(node);\r\n\t\t\t}\r\n\t\t}\r\n\t\tchildren = my_children;\r\n\t}\r\n\t/*\r\n\t * Reorder claimed children optimally.\r\n\t * We can reorder claimed children optimally by finding the longest subsequence of\r\n\t * nodes that are already claimed in order and only moving the rest. The longest\r\n\t * subsequence of nodes that are claimed in order can be found by\r\n\t * computing the longest increasing subsequence of .claim_order values.\r\n\t *\r\n\t * This algorithm is optimal in generating the least amount of reorder operations\r\n\t * possible.\r\n\t *\r\n\t * Proof:\r\n\t * We know that, given a set of reordering operations, the nodes that do not move\r\n\t * always form an increasing subsequence, since they do not move among each other\r\n\t * meaning that they must be already ordered among each other. Thus, the maximal\r\n\t * set of nodes that do not move form a longest increasing subsequence.\r\n\t */\r\n\t// Compute longest increasing subsequence\r\n\t// m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\r\n\tconst m = new Int32Array(children.length + 1);\r\n\t// Predecessor indices + 1\r\n\tconst p = new Int32Array(children.length);\r\n\tm[0] = -1;\r\n\tlet longest = 0;\r\n\tfor (let i = 0; i < children.length; i++) {\r\n\t\tconst current = children[i].claim_order;\r\n\t\t// Find the largest subsequence length such that it ends in a value less than our current value\r\n\t\t// upper_bound returns first greater value, so we subtract one\r\n\t\t// with fast path for when we are on the current longest subsequence\r\n\t\tconst seq_len =\r\n\t\t\t(longest > 0 && children[m[longest]].claim_order <= current\r\n\t\t\t\t? longest + 1\r\n\t\t\t\t: upper_bound(1, longest, (idx) => children[m[idx]].claim_order, current)) - 1;\r\n\t\tp[i] = m[seq_len] + 1;\r\n\t\tconst new_len = seq_len + 1;\r\n\t\t// We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\r\n\t\tm[new_len] = i;\r\n\t\tlongest = Math.max(new_len, longest);\r\n\t}\r\n\t// The longest increasing subsequence of nodes (initially reversed)\r\n\r\n\t/**\r\n\t * @type {NodeEx2[]}\r\n\t */\r\n\tconst lis = [];\r\n\t// The rest of the nodes, nodes that will be moved\r\n\r\n\t/**\r\n\t * @type {NodeEx2[]}\r\n\t */\r\n\tconst to_move = [];\r\n\tlet last = children.length - 1;\r\n\tfor (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\r\n\t\tlis.push(children[cur - 1]);\r\n\t\tfor (; last >= cur; last--) {\r\n\t\t\tto_move.push(children[last]);\r\n\t\t}\r\n\t\tlast--;\r\n\t}\r\n\tfor (; last >= 0; last--) {\r\n\t\tto_move.push(children[last]);\r\n\t}\r\n\tlis.reverse();\r\n\t// We sort the nodes being moved to guarantee that their insertion order matches the claim order\r\n\tto_move.sort((a, b) => a.claim_order - b.claim_order);\r\n\t// Finally, we move the nodes\r\n\tfor (let i = 0, j = 0; i < to_move.length; i++) {\r\n\t\twhile (j < lis.length && to_move[i].claim_order >= lis[j].claim_order) {\r\n\t\t\tj++;\r\n\t\t}\r\n\t\tconst anchor = j < lis.length ? lis[j] : null;\r\n\t\ttarget.insertBefore(to_move[i], anchor);\r\n\t}\r\n}\r\n\r\n/**\r\n * @param {Node} target\r\n * @param {Node} node\r\n * @returns {void}\r\n */\r\nexport function append(target, node) {\r\n\ttarget.appendChild(node);\r\n}\r\n\r\n/**\r\n * @param {Node} target\r\n * @param {string} style_sheet_id\r\n * @param {string} styles\r\n * @returns {void}\r\n */\r\nexport function append_styles(target, style_sheet_id, styles) {\r\n\tconst append_styles_to = get_root_for_style(target);\r\n\tif (!append_styles_to.getElementById(style_sheet_id)) {\r\n\t\tconst style = element('style');\r\n\t\tstyle.id = style_sheet_id;\r\n\t\tstyle.textContent = styles;\r\n\t\tappend_stylesheet(append_styles_to, style);\r\n\t}\r\n}\r\n\r\n/**\r\n * @param {Node} node\r\n * @returns {ShadowRoot | Document}\r\n */\r\nexport function get_root_for_style(node) {\r\n\tif (!node) return document;\r\n\tconst root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\r\n\tif (root && /** @type {ShadowRoot} */ (root).host) {\r\n\t\treturn /** @type {ShadowRoot} */ (root);\r\n\t}\r\n\treturn node.ownerDocument;\r\n}\r\n\r\n/**\r\n * @param {Node} node\r\n * @returns {CSSStyleSheet}\r\n */\r\nexport function append_empty_stylesheet(node) {\r\n\tconst style_element = element('style');\r\n\t// For transitions to work without 'style-src: unsafe-inline' Content Security Policy,\r\n\t// these empty tags need to be allowed with a hash as a workaround until we move to the Web Animations API.\r\n\t// Using the hash for the empty string (for an empty tag) works in all browsers except Safari.\r\n\t// So as a workaround for the workaround, when we append empty style tags we set their content to /* empty */.\r\n\t// The hash 'sha256-9OlNO0DNEeaVzHL4RZwCLsBHA8WBQ8toBp/4F5XV2nc=' will then work even in Safari.\r\n\tstyle_element.textContent = '/* empty */';\r\n\tappend_stylesheet(get_root_for_style(node), style_element);\r\n\treturn style_element.sheet;\r\n}\r\n\r\n/**\r\n * @param {ShadowRoot | Document} node\r\n * @param {HTMLStyleElement} style\r\n * @returns {CSSStyleSheet}\r\n */\r\nfunction append_stylesheet(node, style) {\r\n\tappend(/** @type {Document} */ (node).head || node, style);\r\n\treturn style.sheet;\r\n}\r\n\r\n/**\r\n * @param {NodeEx} target\r\n * @param {NodeEx} node\r\n * @returns {void}\r\n */\r\nexport function append_hydration(target, node) {\r\n\tif (is_hydrating) {\r\n\t\tinit_hydrate(target);\r\n\t\tif (\r\n\t\t\ttarget.actual_end_child === undefined ||\r\n\t\t\t(target.actual_end_child !== null && target.actual_end_child.parentNode !== target)\r\n\t\t) {\r\n\t\t\ttarget.actual_end_child = target.firstChild;\r\n\t\t}\r\n\t\t// Skip nodes of undefined ordering\r\n\t\twhile (target.actual_end_child !== null && target.actual_end_child.claim_order === undefined) {\r\n\t\t\ttarget.actual_end_child = target.actual_end_child.nextSibling;\r\n\t\t}\r\n\t\tif (node !== target.actual_end_child) {\r\n\t\t\t// We only insert if the ordering of this node should be modified or the parent node is not target\r\n\t\t\tif (node.claim_order !== undefined || node.parentNode !== target) {\r\n\t\t\t\ttarget.insertBefore(node, target.actual_end_child);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\ttarget.actual_end_child = node.nextSibling;\r\n\t\t}\r\n\t} else if (node.parentNode !== target || node.nextSibling !== null) {\r\n\t\ttarget.appendChild(node);\r\n\t}\r\n}\r\n\r\n/**\r\n * @param {Node} target\r\n * @param {Node} node\r\n * @param {Node} [anchor]\r\n * @returns {void}\r\n */\r\nexport function insert(target, node, anchor) {\r\n\ttarget.insertBefore(node, anchor || null);\r\n}\r\n\r\n/**\r\n * @param {NodeEx} target\r\n * @param {NodeEx} node\r\n * @param {NodeEx} [anchor]\r\n * @returns {void}\r\n */\r\nexport function insert_hydration(target, node, anchor) {\r\n\tif (is_hydrating && !anchor) {\r\n\t\tappend_hydration(target, node);\r\n\t} else if (node.parentNode !== target || node.nextSibling != anchor) {\r\n\t\ttarget.insertBefore(node, anchor || null);\r\n\t}\r\n}\r\n\r\n/**\r\n * @param {Node} node\r\n * @returns {void}\r\n */\r\nexport function detach(node) {\r\n\tif (node.parentNode) {\r\n\t\tnode.parentNode.removeChild(node);\r\n\t}\r\n}\r\n\r\n/**\r\n * @returns {void} */\r\nexport function destroy_each(iterations, detaching) {\r\n\tfor (let i = 0; i < iterations.length; i += 1) {\r\n\t\tif (iterations[i]) iterations[i].d(detaching);\r\n\t}\r\n}\r\n\r\n/**\r\n * @template {keyof HTMLElementTagNameMap} K\r\n * @param {K} name\r\n * @returns {HTMLElementTagNameMap[K]}\r\n */\r\nexport function element(name) {\r\n\treturn document.createElement(name);\r\n}\r\n\r\n/**\r\n * @template {keyof HTMLElementTagNameMap} K\r\n * @param {K} name\r\n * @param {string} is\r\n * @returns {HTMLElementTagNameMap[K]}\r\n */\r\nexport function element_is(name, is) {\r\n\treturn document.createElement(name, { is });\r\n}\r\n\r\n/**\r\n * @template T\r\n * @template {keyof T} K\r\n * @param {T} obj\r\n * @param {K[]} exclude\r\n * @returns {Pick<T, Exclude<keyof T, K>>}\r\n */\r\nexport function object_without_properties(obj, exclude) {\r\n\tconst target = /** @type {Pick<T, Exclude<keyof T, K>>} */ ({});\r\n\tfor (const k in obj) {\r\n\t\tif (\r\n\t\t\thas_prop(obj, k) &&\r\n\t\t\t// @ts-ignore\r\n\t\t\texclude.indexOf(k) === -1\r\n\t\t) {\r\n\t\t\t// @ts-ignore\r\n\t\t\ttarget[k] = obj[k];\r\n\t\t}\r\n\t}\r\n\treturn target;\r\n}\r\n\r\n/**\r\n * @template {keyof SVGElementTagNameMap} K\r\n * @param {K} name\r\n * @returns {SVGElement}\r\n */\r\nexport function svg_element(name) {\r\n\treturn document.createElementNS('http://www.w3.org/2000/svg', name);\r\n}\r\n\r\n/**\r\n * @param {string} data\r\n * @returns {Text}\r\n */\r\nexport function text(data) {\r\n\treturn document.createTextNode(data);\r\n}\r\n\r\n/**\r\n * @returns {Text} */\r\nexport function space() {\r\n\treturn text(' ');\r\n}\r\n\r\n/**\r\n * @returns {Text} */\r\nexport function empty() {\r\n\treturn text('');\r\n}\r\n\r\n/**\r\n * @param {string} content\r\n * @returns {Comment}\r\n */\r\nexport function comment(content) {\r\n\treturn document.createComment(content);\r\n}\r\n\r\n/**\r\n * @param {EventTarget} node\r\n * @param {string} event\r\n * @param {EventListenerOrEventListenerObject} handler\r\n * @param {boolean | AddEventListenerOptions | EventListenerOptions} [options]\r\n * @returns {() => void}\r\n */\r\nexport function listen(node, event, handler, options) {\r\n\tnode.addEventListener(event, handler, options);\r\n\treturn () => node.removeEventListener(event, handler, options);\r\n}\r\n\r\n/**\r\n * @returns {(event: any) => any} */\r\nexport function prevent_default(fn) {\r\n\treturn function (event) {\r\n\t\tevent.preventDefault();\r\n\t\t// @ts-ignore\r\n\t\treturn fn.call(this, event);\r\n\t};\r\n}\r\n\r\n/**\r\n * @returns {(event: any) => any} */\r\nexport function stop_propagation(fn) {\r\n\treturn function (event) {\r\n\t\tevent.stopPropagation();\r\n\t\t// @ts-ignore\r\n\t\treturn fn.call(this, event);\r\n\t};\r\n}\r\n\r\n/**\r\n * @returns {(event: any) => any} */\r\nexport function stop_immediate_propagation(fn) {\r\n\treturn function (event) {\r\n\t\tevent.stopImmediatePropagation();\r\n\t\t// @ts-ignore\r\n\t\treturn fn.call(this, event);\r\n\t};\r\n}\r\n\r\n/**\r\n * @returns {(event: any) => void} */\r\nexport function self(fn) {\r\n\treturn function (event) {\r\n\t\t// @ts-ignore\r\n\t\tif (event.target === this) fn.call(this, event);\r\n\t};\r\n}\r\n\r\n/**\r\n * @returns {(event: any) => void} */\r\nexport function trusted(fn) {\r\n\treturn function (event) {\r\n\t\t// @ts-ignore\r\n\t\tif (event.isTrusted) fn.call(this, event);\r\n\t};\r\n}\r\n\r\n/**\r\n * @param {Element} node\r\n * @param {string} attribute\r\n * @param {string} [value]\r\n * @returns {void}\r\n */\r\nexport function attr(node, attribute, value) {\r\n\tif (value == null) node.removeAttribute(attribute);\r\n\telse if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);\r\n}\r\n/**\r\n * List of attributes that should always be set through the attr method,\r\n * because updating them through the property setter doesn't work reliably.\r\n * In the example of `width`/`height`, the problem is that the setter only\r\n * accepts numeric values, but the attribute can also be set to a string like `50%`.\r\n * If this list becomes too big, rethink this approach.\r\n */\r\nconst always_set_through_set_attribute = ['width', 'height'];\r\n\r\n/**\r\n * @param {Element & ElementCSSInlineStyle} node\r\n * @param {{ [x: string]: string }} attributes\r\n * @returns {void}\r\n */\r\nexport function set_attributes(node, attributes) {\r\n\t// @ts-ignore\r\n\tconst descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\r\n\tfor (const key in attributes) {\r\n\t\tif (attributes[key] == null) {\r\n\t\t\tnode.removeAttribute(key);\r\n\t\t} else if (key === 'style') {\r\n\t\t\tnode.style.cssText = attributes[key];\r\n\t\t} else if (key === '__value') {\r\n\t\t\t/** @type {any} */ (node).value = node[key] = attributes[key];\r\n\t\t} else if (\r\n\t\t\tdescriptors[key] &&\r\n\t\t\tdescriptors[key].set &&\r\n\t\t\talways_set_through_set_attribute.indexOf(key) === -1\r\n\t\t) {\r\n\t\t\tnode[key] = attributes[key];\r\n\t\t} else {\r\n\t\t\tattr(node, key, attributes[key]);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * @param {Element & ElementCSSInlineStyle} node\r\n * @param {{ [x: string]: string }} attributes\r\n * @returns {void}\r\n */\r\nexport function set_svg_attributes(node, attributes) {\r\n\tfor (const key in attributes) {\r\n\t\tattr(node, key, attributes[key]);\r\n\t}\r\n}\r\n\r\n/**\r\n * @param {Record<string, unknown>} data_map\r\n * @returns {void}\r\n */\r\nexport function set_custom_element_data_map(node, data_map) {\r\n\tObject.keys(data_map).forEach((key) => {\r\n\t\tset_custom_element_data(node, key, data_map[key]);\r\n\t});\r\n}\r\n\r\n/**\r\n * @returns {void} */\r\nexport function set_custom_element_data(node, prop, value) {\r\n\tconst lower = prop.toLowerCase(); // for backwards compatibility with existing behavior we do lowercase first\r\n\tif (lower in node) {\r\n\t\tnode[lower] = typeof node[lower] === 'boolean' && value === '' ? true : value;\r\n\t} else if (prop in node) {\r\n\t\tnode[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\r\n\t} else {\r\n\t\tattr(node, prop, value);\r\n\t}\r\n}\r\n\r\n/**\r\n * @param {string} tag\r\n */\r\nexport function set_dynamic_element_data(tag) {\r\n\treturn /-/.test(tag) ? set_custom_element_data_map : set_attributes;\r\n}\r\n\r\n/**\r\n * @returns {void}\r\n */\r\nexport function xlink_attr(node, attribute, value) {\r\n\tnode.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\r\n}\r\n\r\n/**\r\n * @param {HTMLElement} node\r\n * @returns {string}\r\n */\r\nexport function get_svelte_dataset(node) {\r\n\treturn node.dataset.svelteH;\r\n}\r\n\r\n/**\r\n * @returns {unknown[]} */\r\nexport function get_binding_group_value(group, __value, checked) {\r\n\tconst value = new Set();\r\n\tfor (let i = 0; i < group.length; i += 1) {\r\n\t\tif (group[i].checked) value.add(group[i].__value);\r\n\t}\r\n\tif (!checked) {\r\n\t\tvalue.delete(__value);\r\n\t}\r\n\treturn Array.from(value);\r\n}\r\n\r\n/**\r\n * @param {HTMLInputElement[]} group\r\n * @returns {{ p(...inputs: HTMLInputElement[]): void; r(): void; }}\r\n */\r\nexport function init_binding_group(group) {\r\n\t/**\r\n\t * @type {HTMLInputElement[]} */\r\n\tlet _inputs;\r\n\treturn {\r\n\t\t/* push */ p(...inputs) {\r\n\t\t\t_inputs = inputs;\r\n\t\t\t_inputs.forEach((input) => group.push(input));\r\n\t\t},\r\n\t\t/* remove */ r() {\r\n\t\t\t_inputs.forEach((input) => group.splice(group.indexOf(input), 1));\r\n\t\t}\r\n\t};\r\n}\r\n\r\n/**\r\n * @param {number[]} indexes\r\n * @returns {{ u(new_indexes: number[]): void; p(...inputs: HTMLInputElement[]): void; r: () => void; }}\r\n */\r\nexport function init_binding_group_dynamic(group, indexes) {\r\n\t/**\r\n\t * @type {HTMLInputElement[]} */\r\n\tlet _group = get_binding_group(group);\r\n\r\n\t/**\r\n\t * @type {HTMLInputElement[]} */\r\n\tlet _inputs;\r\n\r\n\tfunction get_binding_group(group) {\r\n\t\tfor (let i = 0; i < indexes.length; i++) {\r\n\t\t\tgroup = group[indexes[i]] = group[indexes[i]] || [];\r\n\t\t}\r\n\t\treturn group;\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {void} */\r\n\tfunction push() {\r\n\t\t_inputs.forEach((input) => _group.push(input));\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {void} */\r\n\tfunction remove() {\r\n\t\t_inputs.forEach((input) => _group.splice(_group.indexOf(input), 1));\r\n\t}\r\n\treturn {\r\n\t\t/* update */ u(new_indexes) {\r\n\t\t\tindexes = new_indexes;\r\n\t\t\tconst new_group = get_binding_group(group);\r\n\t\t\tif (new_group !== _group) {\r\n\t\t\t\tremove();\r\n\t\t\t\t_group = new_group;\r\n\t\t\t\tpush();\r\n\t\t\t}\r\n\t\t},\r\n\t\t/* push */ p(...inputs) {\r\n\t\t\t_inputs = inputs;\r\n\t\t\tpush();\r\n\t\t},\r\n\t\t/* remove */ r: remove\r\n\t};\r\n}\r\n\r\n/** @returns {number} */\r\nexport function to_number(value) {\r\n\treturn value === '' ? null : +value;\r\n}\r\n\r\n/** @returns {any[]} */\r\nexport function time_ranges_to_array(ranges) {\r\n\tconst array = [];\r\n\tfor (let i = 0; i < ranges.length; i += 1) {\r\n\t\tarray.push({ start: ranges.start(i), end: ranges.end(i) });\r\n\t}\r\n\treturn array;\r\n}\r\n\r\n/**\r\n * @param {Element} element\r\n * @returns {ChildNode[]}\r\n */\r\nexport function children(element) {\r\n\treturn Array.from(element.childNodes);\r\n}\r\n\r\n/**\r\n * @param {ChildNodeArray} nodes\r\n * @returns {void}\r\n */\r\nfunction init_claim_info(nodes) {\r\n\tif (nodes.claim_info === undefined) {\r\n\t\tnodes.claim_info = { last_index: 0, total_claimed: 0 };\r\n\t}\r\n}\r\n\r\n/**\r\n * @template {ChildNodeEx} R\r\n * @param {ChildNodeArray} nodes\r\n * @param {(node: ChildNodeEx) => node is R} predicate\r\n * @param {(node: ChildNodeEx) => ChildNodeEx | undefined} process_node\r\n * @param {() => R} create_node\r\n * @param {boolean} dont_update_last_index\r\n * @returns {R}\r\n */\r\nfunction claim_node(nodes, predicate, process_node, create_node, dont_update_last_index = false) {\r\n\t// Try to find nodes in an order such that we lengthen the longest increasing subsequence\r\n\tinit_claim_info(nodes);\r\n\tconst result_node = (() => {\r\n\t\t// We first try to find an element after the previous one\r\n\t\tfor (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\r\n\t\t\tconst node = nodes[i];\r\n\t\t\tif (predicate(node)) {\r\n\t\t\t\tconst replacement = process_node(node);\r\n\t\t\t\tif (replacement === undefined) {\r\n\t\t\t\t\tnodes.splice(i, 1);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tnodes[i] = replacement;\r\n\t\t\t\t}\r\n\t\t\t\tif (!dont_update_last_index) {\r\n\t\t\t\t\tnodes.claim_info.last_index = i;\r\n\t\t\t\t}\r\n\t\t\t\treturn node;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Otherwise, we try to find one before\r\n\t\t// We iterate in reverse so that we don't go too far back\r\n\t\tfor (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\r\n\t\t\tconst node = nodes[i];\r\n\t\t\tif (predicate(node)) {\r\n\t\t\t\tconst replacement = process_node(node);\r\n\t\t\t\tif (replacement === undefined) {\r\n\t\t\t\t\tnodes.splice(i, 1);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tnodes[i] = replacement;\r\n\t\t\t\t}\r\n\t\t\t\tif (!dont_update_last_index) {\r\n\t\t\t\t\tnodes.claim_info.last_index = i;\r\n\t\t\t\t} else if (replacement === undefined) {\r\n\t\t\t\t\t// Since we spliced before the last_index, we decrease it\r\n\t\t\t\t\tnodes.claim_info.last_index--;\r\n\t\t\t\t}\r\n\t\t\t\treturn node;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// If we can't find any matching node, we create a new one\r\n\t\treturn create_node();\r\n\t})();\r\n\tresult_node.claim_order = nodes.claim_info.total_claimed;\r\n\tnodes.claim_info.total_claimed += 1;\r\n\treturn result_node;\r\n}\r\n\r\n/**\r\n * @param {ChildNodeArray} nodes\r\n * @param {string} name\r\n * @param {{ [key: string]: boolean }} attributes\r\n * @param {(name: string) => Element | SVGElement} create_element\r\n * @returns {Element | SVGElement}\r\n */\r\nfunction claim_element_base(nodes, name, attributes, create_element) {\r\n\treturn claim_node(\r\n\t\tnodes,\r\n\t\t/** @returns {node is Element | SVGElement} */\r\n\t\t(node) => node.nodeName === name,\r\n\t\t/** @param {Element} node */\r\n\t\t(node) => {\r\n\t\t\tconst remove = [];\r\n\t\t\tfor (let j = 0; j < node.attributes.length; j++) {\r\n\t\t\t\tconst attribute = node.attributes[j];\r\n\t\t\t\tif (!attributes[attribute.name]) {\r\n\t\t\t\t\tremove.push(attribute.name);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tremove.forEach((v) => node.removeAttribute(v));\r\n\t\t\treturn undefined;\r\n\t\t},\r\n\t\t() => create_element(name)\r\n\t);\r\n}\r\n\r\n/**\r\n * @param {ChildNodeArray} nodes\r\n * @param {string} name\r\n * @param {{ [key: string]: boolean }} attributes\r\n * @returns {Element | SVGElement}\r\n */\r\nexport function claim_element(nodes, name, attributes) {\r\n\treturn claim_element_base(nodes, name, attributes, element);\r\n}\r\n\r\n/**\r\n * @param {ChildNodeArray} nodes\r\n * @param {string} name\r\n * @param {{ [key: string]: boolean }} attributes\r\n * @returns {Element | SVGElement}\r\n */\r\nexport function claim_svg_element(nodes, name, attributes) {\r\n\treturn claim_element_base(nodes, name, attributes, svg_element);\r\n}\r\n\r\n/**\r\n * @param {ChildNodeArray} nodes\r\n * @returns {Text}\r\n */\r\nexport function claim_text(nodes, data) {\r\n\treturn claim_node(\r\n\t\tnodes,\r\n\t\t/** @returns {node is Text} */\r\n\t\t(node) => node.nodeType === 3,\r\n\t\t/** @param {Text} node */\r\n\t\t(node) => {\r\n\t\t\tconst data_str = '' + data;\r\n\t\t\tif (node.data.startsWith(data_str)) {\r\n\t\t\t\tif (node.data.length !== data_str.length) {\r\n\t\t\t\t\treturn node.splitText(data_str.length);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tnode.data = data_str;\r\n\t\t\t}\r\n\t\t},\r\n\t\t() => text(data),\r\n\t\ttrue // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\r\n\t);\r\n}\r\n\r\n/**\r\n * @returns {Text} */\r\nexport function claim_space(nodes) {\r\n\treturn claim_text(nodes, ' ');\r\n}\r\n\r\n/**\r\n * @param {ChildNodeArray} nodes\r\n * @returns {Comment}\r\n */\r\nexport function claim_comment(nodes, data) {\r\n\treturn claim_node(\r\n\t\tnodes,\r\n\t\t/** @returns {node is Comment} */\r\n\t\t(node) => node.nodeType === 8,\r\n\t\t/** @param {Comment} node */\r\n\t\t(node) => {\r\n\t\t\tnode.data = '' + data;\r\n\t\t\treturn undefined;\r\n\t\t},\r\n\t\t() => comment(data),\r\n\t\ttrue\r\n\t);\r\n}\r\n\r\nfunction get_comment_idx(nodes, text, start) {\r\n\tfor (let i = start; i < nodes.length; i += 1) {\r\n\t\tconst node = nodes[i];\r\n\t\tif (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\r\n\t\t\treturn i;\r\n\t\t}\r\n\t}\r\n\treturn -1;\r\n}\r\n\r\n/**\r\n * @param {boolean} is_svg\r\n * @returns {HtmlTagHydration}\r\n */\r\nexport function claim_html_tag(nodes, is_svg) {\r\n\t// find html opening tag\r\n\tconst start_index = get_comment_idx(nodes, 'HTML_TAG_START', 0);\r\n\tconst end_index = get_comment_idx(nodes, 'HTML_TAG_END', start_index + 1);\r\n\tif (start_index === -1 || end_index === -1) {\r\n\t\treturn new HtmlTagHydration(is_svg);\r\n\t}\r\n\r\n\tinit_claim_info(nodes);\r\n\tconst html_tag_nodes = nodes.splice(start_index, end_index - start_index + 1);\r\n\tdetach(html_tag_nodes[0]);\r\n\tdetach(html_tag_nodes[html_tag_nodes.length - 1]);\r\n\tconst claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\r\n\tif (claimed_nodes.length === 0) {\r\n\t\treturn new HtmlTagHydration(is_svg);\r\n\t}\r\n\tfor (const n of claimed_nodes) {\r\n\t\tn.claim_order = nodes.claim_info.total_claimed;\r\n\t\tnodes.claim_info.total_claimed += 1;\r\n\t}\r\n\treturn new HtmlTagHydration(is_svg, claimed_nodes);\r\n}\r\n\r\n/**\r\n * @param {Text} text\r\n * @param {unknown} data\r\n * @returns {void}\r\n */\r\nexport function set_data(text, data) {\r\n\tdata = '' + data;\r\n\tif (text.data === data) return;\r\n\ttext.data = /** @type {string} */ (data);\r\n}\r\n\r\n/**\r\n * @param {Text} text\r\n * @param {unknown} data\r\n * @returns {void}\r\n */\r\nexport function set_data_contenteditable(text, data) {\r\n\tdata = '' + data;\r\n\tif (text.wholeText === data) return;\r\n\ttext.data = /** @type {string} */ (data);\r\n}\r\n\r\n/**\r\n * @param {Text} text\r\n * @param {unknown} data\r\n * @param {string} attr_value\r\n * @returns {void}\r\n */\r\nexport function set_data_maybe_contenteditable(text, data, attr_value) {\r\n\tif (~contenteditable_truthy_values.indexOf(attr_value)) {\r\n\t\tset_data_contenteditable(text, data);\r\n\t} else {\r\n\t\tset_data(text, data);\r\n\t}\r\n}\r\n\r\n/**\r\n * @returns {void} */\r\nexport function set_input_value(input, value) {\r\n\tinput.value = value == null ? '' : value;\r\n}\r\n\r\n/**\r\n * @returns {void} */\r\nexport function set_input_type(input, type) {\r\n\ttry {\r\n\t\tinput.type = type;\r\n\t} catch (e) {\r\n\t\t// do nothing\r\n\t}\r\n}\r\n\r\n/**\r\n * @returns {void} */\r\nexport function set_style(node, key, value, important) {\r\n\tif (value == null) {\r\n\t\tnode.style.removeProperty(key);\r\n\t} else {\r\n\t\tnode.style.setProperty(key, value, important ? 'important' : '');\r\n\t}\r\n}\r\n\r\n/**\r\n * @returns {void} */\r\nexport function select_option(select, value, mounting) {\r\n\tfor (let i = 0; i < select.options.length; i += 1) {\r\n\t\tconst option = select.options[i];\r\n\t\tif (option.__value === value) {\r\n\t\t\toption.selected = true;\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\tif (!mounting || value !== undefined) {\r\n\t\tselect.selectedIndex = -1; // no option should be selected\r\n\t}\r\n}\r\n\r\n/**\r\n * @returns {void} */\r\nexport function select_options(select, value) {\r\n\tfor (let i = 0; i < select.options.length; i += 1) {\r\n\t\tconst option = select.options[i];\r\n\t\toption.selected = ~value.indexOf(option.__value);\r\n\t}\r\n}\r\n\r\nexport function select_value(select) {\r\n\tconst selected_option = select.querySelector(':checked');\r\n\treturn selected_option && selected_option.__value;\r\n}\r\n\r\nexport function select_multiple_value(select) {\r\n\treturn [].map.call(select.querySelectorAll(':checked'), (option) => option.__value);\r\n}\r\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\r\n// so we cache the result instead\r\n\r\n/**\r\n * @type {boolean} */\r\nlet crossorigin;\r\n\r\n/**\r\n * @returns {boolean} */\r\nexport function is_crossorigin() {\r\n\tif (crossorigin === undefined) {\r\n\t\tcrossorigin = false;\r\n\t\ttry {\r\n\t\t\tif (typeof window !== 'undefined' && window.parent) {\r\n\t\t\t\tvoid window.parent.document;\r\n\t\t\t}\r\n\t\t} catch (error) {\r\n\t\t\tcrossorigin = true;\r\n\t\t}\r\n\t}\r\n\treturn crossorigin;\r\n}\r\n\r\n/**\r\n * @param {HTMLElement} node\r\n * @param {() => void} fn\r\n * @returns {() => void}\r\n */\r\nexport function add_iframe_resize_listener(node, fn) {\r\n\tconst computed_style = getComputedStyle(node);\r\n\tif (computed_style.position === 'static') {\r\n\t\tnode.style.position = 'relative';\r\n\t}\r\n\tconst iframe = element('iframe');\r\n\tiframe.setAttribute(\r\n\t\t'style',\r\n\t\t'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\r\n\t\t\t'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;'\r\n\t);\r\n\tiframe.setAttribute('aria-hidden', 'true');\r\n\tiframe.tabIndex = -1;\r\n\tconst crossorigin = is_crossorigin();\r\n\r\n\t/**\r\n\t * @type {() => void}\r\n\t */\r\n\tlet unsubscribe;\r\n\tif (crossorigin) {\r\n\t\tiframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\r\n\t\tunsubscribe = listen(\r\n\t\t\twindow,\r\n\t\t\t'message',\r\n\t\t\t/** @param {MessageEvent} event */ (event) => {\r\n\t\t\t\tif (event.source === iframe.contentWindow) fn();\r\n\t\t\t}\r\n\t\t);\r\n\t} else {\r\n\t\tiframe.src = 'about:blank';\r\n\t\tiframe.onload = () => {\r\n\t\t\tunsubscribe = listen(iframe.contentWindow, 'resize', fn);\r\n\t\t\t// make sure an initial resize event is fired _after_ the iframe is loaded (which is asynchronous)\r\n\t\t\t// see https://github.com/sveltejs/svelte/issues/4233\r\n\t\t\tfn();\r\n\t\t};\r\n\t}\r\n\tappend(node, iframe);\r\n\treturn () => {\r\n\t\tif (crossorigin) {\r\n\t\t\tunsubscribe();\r\n\t\t} else if (unsubscribe && iframe.contentWindow) {\r\n\t\t\tunsubscribe();\r\n\t\t}\r\n\t\tdetach(iframe);\r\n\t};\r\n}\r\nexport const resize_observer_content_box = /* @__PURE__ */ new ResizeObserverSingleton({\r\n\tbox: 'content-box'\r\n});\r\nexport const resize_observer_border_box = /* @__PURE__ */ new ResizeObserverSingleton({\r\n\tbox: 'border-box'\r\n});\r\nexport const resize_observer_device_pixel_content_box = /* @__PURE__ */ new ResizeObserverSingleton(\r\n\t{ box: 'device-pixel-content-box' }\r\n);\r\nexport { ResizeObserverSingleton };\r\n\r\n/**\r\n * @returns {void} */\r\nexport function toggle_class(element, name, toggle) {\r\n\t// The `!!` is required because an `undefined` flag means flipping the current state.\r\n\telement.classList.toggle(name, !!toggle);\r\n}\r\n\r\n/**\r\n * @template T\r\n * @param {string} type\r\n * @param {T} [detail]\r\n * @param {{ bubbles?: boolean, cancelable?: boolean }} [options]\r\n * @returns {CustomEvent<T>}\r\n */\r\nexport function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {\r\n\treturn new CustomEvent(type, { detail, bubbles, cancelable });\r\n}\r\n\r\n/**\r\n * @param {string} selector\r\n * @param {HTMLElement} parent\r\n * @returns {ChildNodeArray}\r\n */\r\nexport function query_selector_all(selector, parent = document.body) {\r\n\treturn Array.from(parent.querySelectorAll(selector));\r\n}\r\n\r\n/**\r\n * @param {string} nodeId\r\n * @param {HTMLElement} head\r\n * @returns {any[]}\r\n */\r\nexport function head_selector(nodeId, head) {\r\n\tconst result = [];\r\n\tlet started = 0;\r\n\tfor (const node of head.childNodes) {\r\n\t\tif (node.nodeType === 8 /* comment node */) {\r\n\t\t\tconst comment = node.textContent.trim();\r\n\t\t\tif (comment === `HEAD_${nodeId}_END`) {\r\n\t\t\t\tstarted -= 1;\r\n\t\t\t\tresult.push(node);\r\n\t\t\t} else if (comment === `HEAD_${nodeId}_START`) {\r\n\t\t\t\tstarted += 1;\r\n\t\t\t\tresult.push(node);\r\n\t\t\t}\r\n\t\t} else if (started > 0) {\r\n\t\t\tresult.push(node);\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n}\r\n/** */\r\nexport class HtmlTag {\r\n\t/**\r\n\t * @private\r\n\t * @default false\r\n\t */\r\n\tis_svg = false;\r\n\t/** parent for creating node */\r\n\te = undefined;\r\n\t/** html tag nodes */\r\n\tn = undefined;\r\n\t/** target */\r\n\tt = undefined;\r\n\t/** anchor */\r\n\ta = undefined;\r\n\tconstructor(is_svg = false) {\r\n\t\tthis.is_svg = is_svg;\r\n\t\tthis.e = this.n = null;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {string} html\r\n\t * @returns {void}\r\n\t */\r\n\tc(html) {\r\n\t\tthis.h(html);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {string} html\r\n\t * @param {HTMLElement | SVGElement} target\r\n\t * @param {HTMLElement | SVGElement} anchor\r\n\t * @returns {void}\r\n\t */\r\n\tm(html, target, anchor = null) {\r\n\t\tif (!this.e) {\r\n\t\t\tif (this.is_svg)\r\n\t\t\t\tthis.e = svg_element(/** @type {keyof SVGElementTagNameMap} */ (target.nodeName));\r\n\t\t\t/** #7364  target for <template> may be provided as #document-fragment(11) */ else\r\n\t\t\t\tthis.e = element(\r\n\t\t\t\t\t/** @type {keyof HTMLElementTagNameMap} */ (\r\n\t\t\t\t\t\ttarget.nodeType === 11 ? 'TEMPLATE' : target.nodeName\r\n\t\t\t\t\t)\r\n\t\t\t\t);\r\n\t\t\tthis.t =\r\n\t\t\t\ttarget.tagName !== 'TEMPLATE'\r\n\t\t\t\t\t? target\r\n\t\t\t\t\t: /** @type {HTMLTemplateElement} */ (target).content;\r\n\t\t\tthis.c(html);\r\n\t\t}\r\n\t\tthis.i(anchor);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {string} html\r\n\t * @returns {void}\r\n\t */\r\n\th(html) {\r\n\t\tthis.e.innerHTML = html;\r\n\t\tthis.n = Array.from(\r\n\t\t\tthis.e.nodeName === 'TEMPLATE' ? this.e.content.childNodes : this.e.childNodes\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {void} */\r\n\ti(anchor) {\r\n\t\tfor (let i = 0; i < this.n.length; i += 1) {\r\n\t\t\tinsert(this.t, this.n[i], anchor);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @param {string} html\r\n\t * @returns {void}\r\n\t */\r\n\tp(html) {\r\n\t\tthis.d();\r\n\t\tthis.h(html);\r\n\t\tthis.i(this.a);\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {void} */\r\n\td() {\r\n\t\tthis.n.forEach(detach);\r\n\t}\r\n}\r\n\r\nexport class HtmlTagHydration extends HtmlTag {\r\n\t/** @type {Element[]} hydration claimed nodes */\r\n\tl = undefined;\r\n\r\n\tconstructor(is_svg = false, claimed_nodes) {\r\n\t\tsuper(is_svg);\r\n\t\tthis.e = this.n = null;\r\n\t\tthis.l = claimed_nodes;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {string} html\r\n\t * @returns {void}\r\n\t */\r\n\tc(html) {\r\n\t\tif (this.l) {\r\n\t\t\tthis.n = this.l;\r\n\t\t} else {\r\n\t\t\tsuper.c(html);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {void} */\r\n\ti(anchor) {\r\n\t\tfor (let i = 0; i < this.n.length; i += 1) {\r\n\t\t\tinsert_hydration(this.t, this.n[i], anchor);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * @param {NamedNodeMap} attributes\r\n * @returns {{}}\r\n */\r\nexport function attribute_to_object(attributes) {\r\n\tconst result = {};\r\n\tfor (const attribute of attributes) {\r\n\t\tresult[attribute.name] = attribute.value;\r\n\t}\r\n\treturn result;\r\n}\r\n\r\nconst escaped = {\r\n\t'\"': '&quot;',\r\n\t'&': '&amp;',\r\n\t'<': '&lt;'\r\n};\r\n\r\nconst regex_attribute_characters_to_escape = /[\"&<]/g;\r\n\r\n/**\r\n * Note that the attribute itself should be surrounded in double quotes\r\n * @param {any} attribute\r\n */\r\nfunction escape_attribute(attribute) {\r\n\treturn String(attribute).replace(regex_attribute_characters_to_escape, (match) => escaped[match]);\r\n}\r\n\r\n/**\r\n * @param {Record<string, string>} attributes\r\n */\r\nexport function stringify_spread(attributes) {\r\n\tlet str = ' ';\r\n\tfor (const key in attributes) {\r\n\t\tif (attributes[key] != null) {\r\n\t\t\tstr += `${key}=\"${escape_attribute(attributes[key])}\" `;\r\n\t\t}\r\n\t}\r\n\r\n\treturn str;\r\n}\r\n\r\n/**\r\n * @param {HTMLElement} element\r\n * @returns {{}}\r\n */\r\nexport function get_custom_elements_slots(element) {\r\n\tconst result = {};\r\n\telement.childNodes.forEach(\r\n\t\t/** @param {Element} node */ (node) => {\r\n\t\t\tresult[node.slot || 'default'] = true;\r\n\t\t}\r\n\t);\r\n\treturn result;\r\n}\r\n\r\nexport function construct_svelte_component(component, props) {\r\n\treturn new component(props);\r\n}\r\n\r\n/**\r\n * @typedef {Node & {\r\n * \tclaim_order?: number;\r\n * \thydrate_init?: true;\r\n * \tactual_end_child?: NodeEx;\r\n * \tchildNodes: NodeListOf<NodeEx>;\r\n * }} NodeEx\r\n */\r\n\r\n/** @typedef {ChildNode & NodeEx} ChildNodeEx */\r\n\r\n/** @typedef {NodeEx & { claim_order: number }} NodeEx2 */\r\n\r\n/**\r\n * @typedef {ChildNodeEx[] & {\r\n * \tclaim_info?: {\r\n * \t\tlast_index: number;\r\n * \t\ttotal_claimed: number;\r\n * \t};\r\n * }} ChildNodeArray\r\n */\r\n","import { custom_event } from './dom.js';\r\n\r\nexport let current_component;\r\n\r\n/** @returns {void} */\r\nexport function set_current_component(component) {\r\n\tcurrent_component = component;\r\n}\r\n\r\nexport function get_current_component() {\r\n\tif (!current_component) throw new Error('Function called outside component initialization');\r\n\treturn current_component;\r\n}\r\n\r\n/**\r\n * Schedules a callback to run immediately before the component is updated after any state change.\r\n *\r\n * The first time the callback runs will be before the initial `onMount`\r\n *\r\n * https://svelte.dev/docs/svelte#beforeupdate\r\n * @param {() => any} fn\r\n * @returns {void}\r\n */\r\nexport function beforeUpdate(fn) {\r\n\tget_current_component().$$.before_update.push(fn);\r\n}\r\n\r\n/**\r\n * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.\r\n * It must be called during the component's initialisation (but doesn't need to live *inside* the component;\r\n * it can be called from an external module).\r\n *\r\n * If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.\r\n *\r\n * `onMount` does not run inside a [server-side component](https://svelte.dev/docs#run-time-server-side-component-api).\r\n *\r\n * https://svelte.dev/docs/svelte#onmount\r\n * @template T\r\n * @param {() => import('./private.js').NotFunction<T> | Promise<import('./private.js').NotFunction<T>> | (() => any)} fn\r\n * @returns {void}\r\n */\r\nexport function onMount(fn) {\r\n\tget_current_component().$$.on_mount.push(fn);\r\n}\r\n\r\n/**\r\n * Schedules a callback to run immediately after the component has been updated.\r\n *\r\n * The first time the callback runs will be after the initial `onMount`\r\n *\r\n * https://svelte.dev/docs/svelte#afterupdate\r\n * @param {() => any} fn\r\n * @returns {void}\r\n */\r\nexport function afterUpdate(fn) {\r\n\tget_current_component().$$.after_update.push(fn);\r\n}\r\n\r\n/**\r\n * Schedules a callback to run immediately before the component is unmounted.\r\n *\r\n * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the\r\n * only one that runs inside a server-side component.\r\n *\r\n * https://svelte.dev/docs/svelte#ondestroy\r\n * @param {() => any} fn\r\n * @returns {void}\r\n */\r\nexport function onDestroy(fn) {\r\n\tget_current_component().$$.on_destroy.push(fn);\r\n}\r\n\r\n/**\r\n * Creates an event dispatcher that can be used to dispatch [component events](https://svelte.dev/docs#template-syntax-component-directives-on-eventname).\r\n * Event dispatchers are functions that can take two arguments: `name` and `detail`.\r\n *\r\n * Component events created with `createEventDispatcher` create a\r\n * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).\r\n * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).\r\n * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)\r\n * property and can contain any type of data.\r\n *\r\n * The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:\r\n * ```ts\r\n * const dispatch = createEventDispatcher<{\r\n *  loaded: never; // does not take a detail argument\r\n *  change: string; // takes a detail argument of type string, which is required\r\n *  optional: number | null; // takes an optional detail argument of type number\r\n * }>();\r\n * ```\r\n *\r\n * https://svelte.dev/docs/svelte#createeventdispatcher\r\n * @template {Record<string, any>} [EventMap=any]\r\n * @returns {import('./public.js').EventDispatcher<EventMap>}\r\n */\r\nexport function createEventDispatcher() {\r\n\tconst component = get_current_component();\r\n\treturn (type, detail, { cancelable = false } = {}) => {\r\n\t\tconst callbacks = component.$$.callbacks[type];\r\n\t\tif (callbacks) {\r\n\t\t\t// TODO are there situations where events could be dispatched\r\n\t\t\t// in a server (non-DOM) environment?\r\n\t\t\tconst event = custom_event(/** @type {string} */ (type), detail, { cancelable });\r\n\t\t\tcallbacks.slice().forEach((fn) => {\r\n\t\t\t\tfn.call(component, event);\r\n\t\t\t});\r\n\t\t\treturn !event.defaultPrevented;\r\n\t\t}\r\n\t\treturn true;\r\n\t};\r\n}\r\n\r\n/**\r\n * Associates an arbitrary `context` object with the current component and the specified `key`\r\n * and returns that object. The context is then available to children of the component\r\n * (including slotted content) with `getContext`.\r\n *\r\n * Like lifecycle functions, this must be called during component initialisation.\r\n *\r\n * https://svelte.dev/docs/svelte#setcontext\r\n * @template T\r\n * @param {any} key\r\n * @param {T} context\r\n * @returns {T}\r\n */\r\nexport function setContext(key, context) {\r\n\tget_current_component().$$.context.set(key, context);\r\n\treturn context;\r\n}\r\n\r\n/**\r\n * Retrieves the context that belongs to the closest parent component with the specified `key`.\r\n * Must be called during component initialisation.\r\n *\r\n * https://svelte.dev/docs/svelte#getcontext\r\n * @template T\r\n * @param {any} key\r\n * @returns {T}\r\n */\r\nexport function getContext(key) {\r\n\treturn get_current_component().$$.context.get(key);\r\n}\r\n\r\n/**\r\n * Retrieves the whole context map that belongs to the closest parent component.\r\n * Must be called during component initialisation. Useful, for example, if you\r\n * programmatically create a component and want to pass the existing context to it.\r\n *\r\n * https://svelte.dev/docs/svelte#getallcontexts\r\n * @template {Map<any, any>} [T=Map<any, any>]\r\n * @returns {T}\r\n */\r\nexport function getAllContexts() {\r\n\treturn get_current_component().$$.context;\r\n}\r\n\r\n/**\r\n * Checks whether a given `key` has been set in the context of a parent component.\r\n * Must be called during component initialisation.\r\n *\r\n * https://svelte.dev/docs/svelte#hascontext\r\n * @param {any} key\r\n * @returns {boolean}\r\n */\r\nexport function hasContext(key) {\r\n\treturn get_current_component().$$.context.has(key);\r\n}\r\n\r\n// TODO figure out if we still want to support\r\n// shorthand events, or if we want to implement\r\n// a real bubbling mechanism\r\n/**\r\n * @param component\r\n * @param event\r\n * @returns {void}\r\n */\r\nexport function bubble(component, event) {\r\n\tconst callbacks = component.$$.callbacks[event.type];\r\n\tif (callbacks) {\r\n\t\t// @ts-ignore\r\n\t\tcallbacks.slice().forEach((fn) => fn.call(this, event));\r\n\t}\r\n}\r\n","import { run_all } from './utils.js';\r\nimport { current_component, set_current_component } from './lifecycle.js';\r\n\r\nexport const dirty_components = [];\r\nexport const intros = { enabled: false };\r\nexport const binding_callbacks = [];\r\n\r\nlet render_callbacks = [];\r\n\r\nconst flush_callbacks = [];\r\n\r\nconst resolved_promise = /* @__PURE__ */ Promise.resolve();\r\n\r\nlet update_scheduled = false;\r\n\r\n/** @returns {void} */\r\nexport function schedule_update() {\r\n\tif (!update_scheduled) {\r\n\t\tupdate_scheduled = true;\r\n\t\tresolved_promise.then(flush);\r\n\t}\r\n}\r\n\r\n/** @returns {Promise<void>} */\r\nexport function tick() {\r\n\tschedule_update();\r\n\treturn resolved_promise;\r\n}\r\n\r\n/** @returns {void} */\r\nexport function add_render_callback(fn) {\r\n\trender_callbacks.push(fn);\r\n}\r\n\r\n/** @returns {void} */\r\nexport function add_flush_callback(fn) {\r\n\tflush_callbacks.push(fn);\r\n}\r\n\r\n// flush() calls callbacks in this order:\r\n// 1. All beforeUpdate callbacks, in order: parents before children\r\n// 2. All bind:this callbacks, in reverse order: children before parents.\r\n// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\r\n//    for afterUpdates called during the initial onMount, which are called in\r\n//    reverse order: children before parents.\r\n// Since callbacks might update component values, which could trigger another\r\n// call to flush(), the following steps guard against this:\r\n// 1. During beforeUpdate, any updated components will be added to the\r\n//    dirty_components array and will cause a reentrant call to flush(). Because\r\n//    the flush index is kept outside the function, the reentrant call will pick\r\n//    up where the earlier call left off and go through all dirty components. The\r\n//    current_component value is saved and restored so that the reentrant call will\r\n//    not interfere with the \"parent\" flush() call.\r\n// 2. bind:this callbacks cannot trigger new flush() calls.\r\n// 3. During afterUpdate, any updated components will NOT have their afterUpdate\r\n//    callback called a second time; the seen_callbacks set, outside the flush()\r\n//    function, guarantees this behavior.\r\nconst seen_callbacks = new Set();\r\n\r\nlet flushidx = 0; // Do *not* move this inside the flush() function\r\n\r\n/** @returns {void} */\r\nexport function flush() {\r\n\t// Do not reenter flush while dirty components are updated, as this can\r\n\t// result in an infinite loop. Instead, let the inner flush handle it.\r\n\t// Reentrancy is ok afterwards for bindings etc.\r\n\tif (flushidx !== 0) {\r\n\t\treturn;\r\n\t}\r\n\tconst saved_component = current_component;\r\n\tdo {\r\n\t\t// first, call beforeUpdate functions\r\n\t\t// and update components\r\n\t\ttry {\r\n\t\t\twhile (flushidx < dirty_components.length) {\r\n\t\t\t\tconst component = dirty_components[flushidx];\r\n\t\t\t\tflushidx++;\r\n\t\t\t\tset_current_component(component);\r\n\t\t\t\tupdate(component.$$);\r\n\t\t\t}\r\n\t\t} catch (e) {\r\n\t\t\t// reset dirty state to not end up in a deadlocked state and then rethrow\r\n\t\t\tdirty_components.length = 0;\r\n\t\t\tflushidx = 0;\r\n\t\t\tthrow e;\r\n\t\t}\r\n\t\tset_current_component(null);\r\n\t\tdirty_components.length = 0;\r\n\t\tflushidx = 0;\r\n\t\twhile (binding_callbacks.length) binding_callbacks.pop()();\r\n\t\t// then, once components are updated, call\r\n\t\t// afterUpdate functions. This may cause\r\n\t\t// subsequent updates...\r\n\t\tfor (let i = 0; i < render_callbacks.length; i += 1) {\r\n\t\t\tconst callback = render_callbacks[i];\r\n\t\t\tif (!seen_callbacks.has(callback)) {\r\n\t\t\t\t// ...so guard against infinite loops\r\n\t\t\t\tseen_callbacks.add(callback);\r\n\t\t\t\tcallback();\r\n\t\t\t}\r\n\t\t}\r\n\t\trender_callbacks.length = 0;\r\n\t} while (dirty_components.length);\r\n\twhile (flush_callbacks.length) {\r\n\t\tflush_callbacks.pop()();\r\n\t}\r\n\tupdate_scheduled = false;\r\n\tseen_callbacks.clear();\r\n\tset_current_component(saved_component);\r\n}\r\n\r\n/** @returns {void} */\r\nfunction update($$) {\r\n\tif ($$.fragment !== null) {\r\n\t\t$$.update();\r\n\t\trun_all($$.before_update);\r\n\t\tconst dirty = $$.dirty;\r\n\t\t$$.dirty = [-1];\r\n\t\t$$.fragment && $$.fragment.p($$.ctx, dirty);\r\n\t\t$$.after_update.forEach(add_render_callback);\r\n\t}\r\n}\r\n\r\n/**\r\n * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.\r\n * @param {Function[]} fns\r\n * @returns {void}\r\n */\r\nexport function flush_render_callbacks(fns) {\r\n\tconst filtered = [];\r\n\tconst targets = [];\r\n\trender_callbacks.forEach((c) => (fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c)));\r\n\ttargets.forEach((c) => c());\r\n\trender_callbacks = filtered;\r\n}\r\n","import { identity as linear, is_function, noop, run_all } from './utils.js';\r\nimport { now } from './environment.js';\r\nimport { loop } from './loop.js';\r\nimport { create_rule, delete_rule } from './style_manager.js';\r\nimport { custom_event } from './dom.js';\r\nimport { add_render_callback } from './scheduler.js';\r\n\r\n/**\r\n * @type {Promise<void> | null}\r\n */\r\nlet promise;\r\n\r\n/**\r\n * @returns {Promise<void>}\r\n */\r\nfunction wait() {\r\n\tif (!promise) {\r\n\t\tpromise = Promise.resolve();\r\n\t\tpromise.then(() => {\r\n\t\t\tpromise = null;\r\n\t\t});\r\n\t}\r\n\treturn promise;\r\n}\r\n\r\n/**\r\n * @param {Element} node\r\n * @param {INTRO | OUTRO | boolean} direction\r\n * @param {'start' | 'end'} kind\r\n * @returns {void}\r\n */\r\nfunction dispatch(node, direction, kind) {\r\n\tnode.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\r\n}\r\n\r\nconst outroing = new Set();\r\n\r\n/**\r\n * @type {Outro}\r\n */\r\nlet outros;\r\n\r\n/**\r\n * @returns {void} */\r\nexport function group_outros() {\r\n\toutros = {\r\n\t\tr: 0,\r\n\t\tc: [],\r\n\t\tp: outros // parent group\r\n\t};\r\n}\r\n\r\n/**\r\n * @returns {void} */\r\nexport function check_outros() {\r\n\tif (!outros.r) {\r\n\t\trun_all(outros.c);\r\n\t}\r\n\toutros = outros.p;\r\n}\r\n\r\n/**\r\n * @param {import('./private.js').Fragment} block\r\n * @param {0 | 1} [local]\r\n * @returns {void}\r\n */\r\nexport function transition_in(block, local) {\r\n\tif (block && block.i) {\r\n\t\toutroing.delete(block);\r\n\t\tblock.i(local);\r\n\t}\r\n}\r\n\r\n/**\r\n * @param {import('./private.js').Fragment} block\r\n * @param {0 | 1} local\r\n * @param {0 | 1} [detach]\r\n * @param {() => void} [callback]\r\n * @returns {void}\r\n */\r\nexport function transition_out(block, local, detach, callback) {\r\n\tif (block && block.o) {\r\n\t\tif (outroing.has(block)) return;\r\n\t\toutroing.add(block);\r\n\t\toutros.c.push(() => {\r\n\t\t\toutroing.delete(block);\r\n\t\t\tif (callback) {\r\n\t\t\t\tif (detach) block.d(1);\r\n\t\t\t\tcallback();\r\n\t\t\t}\r\n\t\t});\r\n\t\tblock.o(local);\r\n\t} else if (callback) {\r\n\t\tcallback();\r\n\t}\r\n}\r\n\r\n/**\r\n * @type {import('../transition/public.js').TransitionConfig}\r\n */\r\nconst null_transition = { duration: 0 };\r\n\r\n/**\r\n * @param {Element & ElementCSSInlineStyle} node\r\n * @param {TransitionFn} fn\r\n * @param {any} params\r\n * @returns {{ start(): void; invalidate(): void; end(): void; }}\r\n */\r\nexport function create_in_transition(node, fn, params) {\r\n\t/**\r\n\t * @type {TransitionOptions} */\r\n\tconst options = { direction: 'in' };\r\n\tlet config = fn(node, params, options);\r\n\tlet running = false;\r\n\tlet animation_name;\r\n\tlet task;\r\n\tlet uid = 0;\r\n\r\n\t/**\r\n\t * @returns {void} */\r\n\tfunction cleanup() {\r\n\t\tif (animation_name) delete_rule(node, animation_name);\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {void} */\r\n\tfunction go() {\r\n\t\tconst {\r\n\t\t\tdelay = 0,\r\n\t\t\tduration = 300,\r\n\t\t\teasing = linear,\r\n\t\t\ttick = noop,\r\n\t\t\tcss\r\n\t\t} = config || null_transition;\r\n\t\tif (css) animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\r\n\t\ttick(0, 1);\r\n\t\tconst start_time = now() + delay;\r\n\t\tconst end_time = start_time + duration;\r\n\t\tif (task) task.abort();\r\n\t\trunning = true;\r\n\t\tadd_render_callback(() => dispatch(node, true, 'start'));\r\n\t\ttask = loop((now) => {\r\n\t\t\tif (running) {\r\n\t\t\t\tif (now >= end_time) {\r\n\t\t\t\t\ttick(1, 0);\r\n\t\t\t\t\tdispatch(node, true, 'end');\r\n\t\t\t\t\tcleanup();\r\n\t\t\t\t\treturn (running = false);\r\n\t\t\t\t}\r\n\t\t\t\tif (now >= start_time) {\r\n\t\t\t\t\tconst t = easing((now - start_time) / duration);\r\n\t\t\t\t\ttick(t, 1 - t);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn running;\r\n\t\t});\r\n\t}\r\n\tlet started = false;\r\n\treturn {\r\n\t\tstart() {\r\n\t\t\tif (started) return;\r\n\t\t\tstarted = true;\r\n\t\t\tdelete_rule(node);\r\n\t\t\tif (is_function(config)) {\r\n\t\t\t\tconfig = config(options);\r\n\t\t\t\twait().then(go);\r\n\t\t\t} else {\r\n\t\t\t\tgo();\r\n\t\t\t}\r\n\t\t},\r\n\t\tinvalidate() {\r\n\t\t\tstarted = false;\r\n\t\t},\r\n\t\tend() {\r\n\t\t\tif (running) {\r\n\t\t\t\tcleanup();\r\n\t\t\t\trunning = false;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n\r\n/**\r\n * @param {Element & ElementCSSInlineStyle} node\r\n * @param {TransitionFn} fn\r\n * @param {any} params\r\n * @returns {{ end(reset: any): void; }}\r\n */\r\nexport function create_out_transition(node, fn, params) {\r\n\t/** @type {TransitionOptions} */\r\n\tconst options = { direction: 'out' };\r\n\tlet config = fn(node, params, options);\r\n\tlet running = true;\r\n\tlet animation_name;\r\n\tconst group = outros;\r\n\tgroup.r += 1;\r\n\t/** @type {boolean} */\r\n\tlet original_inert_value;\r\n\r\n\t/**\r\n\t * @returns {void} */\r\n\tfunction go() {\r\n\t\tconst {\r\n\t\t\tdelay = 0,\r\n\t\t\tduration = 300,\r\n\t\t\teasing = linear,\r\n\t\t\ttick = noop,\r\n\t\t\tcss\r\n\t\t} = config || null_transition;\r\n\r\n\t\tif (css) animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\r\n\r\n\t\tconst start_time = now() + delay;\r\n\t\tconst end_time = start_time + duration;\r\n\t\tadd_render_callback(() => dispatch(node, false, 'start'));\r\n\r\n\t\tif ('inert' in node) {\r\n\t\t\toriginal_inert_value = /** @type {HTMLElement} */ (node).inert;\r\n\t\t\tnode.inert = true;\r\n\t\t}\r\n\r\n\t\tloop((now) => {\r\n\t\t\tif (running) {\r\n\t\t\t\tif (now >= end_time) {\r\n\t\t\t\t\ttick(0, 1);\r\n\t\t\t\t\tdispatch(node, false, 'end');\r\n\t\t\t\t\tif (!--group.r) {\r\n\t\t\t\t\t\t// this will result in `end()` being called,\r\n\t\t\t\t\t\t// so we don't need to clean up here\r\n\t\t\t\t\t\trun_all(group.c);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\tif (now >= start_time) {\r\n\t\t\t\t\tconst t = easing((now - start_time) / duration);\r\n\t\t\t\t\ttick(1 - t, t);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn running;\r\n\t\t});\r\n\t}\r\n\r\n\tif (is_function(config)) {\r\n\t\twait().then(() => {\r\n\t\t\t// @ts-ignore\r\n\t\t\tconfig = config(options);\r\n\t\t\tgo();\r\n\t\t});\r\n\t} else {\r\n\t\tgo();\r\n\t}\r\n\r\n\treturn {\r\n\t\tend(reset) {\r\n\t\t\tif (reset && 'inert' in node) {\r\n\t\t\t\tnode.inert = original_inert_value;\r\n\t\t\t}\r\n\t\t\tif (reset && config.tick) {\r\n\t\t\t\tconfig.tick(1, 0);\r\n\t\t\t}\r\n\t\t\tif (running) {\r\n\t\t\t\tif (animation_name) delete_rule(node, animation_name);\r\n\t\t\t\trunning = false;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n\r\n/**\r\n * @param {Element & ElementCSSInlineStyle} node\r\n * @param {TransitionFn} fn\r\n * @param {any} params\r\n * @param {boolean} intro\r\n * @returns {{ run(b: 0 | 1): void; end(): void; }}\r\n */\r\nexport function create_bidirectional_transition(node, fn, params, intro) {\r\n\t/**\r\n\t * @type {TransitionOptions} */\r\n\tconst options = { direction: 'both' };\r\n\tlet config = fn(node, params, options);\r\n\tlet t = intro ? 0 : 1;\r\n\r\n\t/**\r\n\t * @type {Program | null} */\r\n\tlet running_program = null;\r\n\r\n\t/**\r\n\t * @type {PendingProgram | null} */\r\n\tlet pending_program = null;\r\n\tlet animation_name = null;\r\n\r\n\t/** @type {boolean} */\r\n\tlet original_inert_value;\r\n\r\n\t/**\r\n\t * @returns {void} */\r\n\tfunction clear_animation() {\r\n\t\tif (animation_name) delete_rule(node, animation_name);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {PendingProgram} program\r\n\t * @param {number} duration\r\n\t * @returns {Program}\r\n\t */\r\n\tfunction init(program, duration) {\r\n\t\tconst d = /** @type {Program['d']} */ (program.b - t);\r\n\t\tduration *= Math.abs(d);\r\n\t\treturn {\r\n\t\t\ta: t,\r\n\t\t\tb: program.b,\r\n\t\t\td,\r\n\t\t\tduration,\r\n\t\t\tstart: program.start,\r\n\t\t\tend: program.start + duration,\r\n\t\t\tgroup: program.group\r\n\t\t};\r\n\t}\r\n\r\n\t/**\r\n\t * @param {INTRO | OUTRO} b\r\n\t * @returns {void}\r\n\t */\r\n\tfunction go(b) {\r\n\t\tconst {\r\n\t\t\tdelay = 0,\r\n\t\t\tduration = 300,\r\n\t\t\teasing = linear,\r\n\t\t\ttick = noop,\r\n\t\t\tcss\r\n\t\t} = config || null_transition;\r\n\r\n\t\t/**\r\n\t\t * @type {PendingProgram} */\r\n\t\tconst program = {\r\n\t\t\tstart: now() + delay,\r\n\t\t\tb\r\n\t\t};\r\n\r\n\t\tif (!b) {\r\n\t\t\t// @ts-ignore todo: improve typings\r\n\t\t\tprogram.group = outros;\r\n\t\t\toutros.r += 1;\r\n\t\t}\r\n\r\n\t\tif ('inert' in node) {\r\n\t\t\tif (b) {\r\n\t\t\t\tif (original_inert_value !== undefined) {\r\n\t\t\t\t\t// aborted/reversed outro  restore previous inert value\r\n\t\t\t\t\tnode.inert = original_inert_value;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\toriginal_inert_value = /** @type {HTMLElement} */ (node).inert;\r\n\t\t\t\tnode.inert = true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (running_program || pending_program) {\r\n\t\t\tpending_program = program;\r\n\t\t} else {\r\n\t\t\t// if this is an intro, and there's a delay, we need to do\r\n\t\t\t// an initial tick and/or apply CSS animation immediately\r\n\t\t\tif (css) {\r\n\t\t\t\tclear_animation();\r\n\t\t\t\tanimation_name = create_rule(node, t, b, duration, delay, easing, css);\r\n\t\t\t}\r\n\t\t\tif (b) tick(0, 1);\r\n\t\t\trunning_program = init(program, duration);\r\n\t\t\tadd_render_callback(() => dispatch(node, b, 'start'));\r\n\t\t\tloop((now) => {\r\n\t\t\t\tif (pending_program && now > pending_program.start) {\r\n\t\t\t\t\trunning_program = init(pending_program, duration);\r\n\t\t\t\t\tpending_program = null;\r\n\t\t\t\t\tdispatch(node, running_program.b, 'start');\r\n\t\t\t\t\tif (css) {\r\n\t\t\t\t\t\tclear_animation();\r\n\t\t\t\t\t\tanimation_name = create_rule(\r\n\t\t\t\t\t\t\tnode,\r\n\t\t\t\t\t\t\tt,\r\n\t\t\t\t\t\t\trunning_program.b,\r\n\t\t\t\t\t\t\trunning_program.duration,\r\n\t\t\t\t\t\t\t0,\r\n\t\t\t\t\t\t\teasing,\r\n\t\t\t\t\t\t\tconfig.css\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (running_program) {\r\n\t\t\t\t\tif (now >= running_program.end) {\r\n\t\t\t\t\t\ttick((t = running_program.b), 1 - t);\r\n\t\t\t\t\t\tdispatch(node, running_program.b, 'end');\r\n\t\t\t\t\t\tif (!pending_program) {\r\n\t\t\t\t\t\t\t// we're done\r\n\t\t\t\t\t\t\tif (running_program.b) {\r\n\t\t\t\t\t\t\t\t// intro  we can tidy up immediately\r\n\t\t\t\t\t\t\t\tclear_animation();\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// outro  needs to be coordinated\r\n\t\t\t\t\t\t\t\tif (!--running_program.group.r) run_all(running_program.group.c);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\trunning_program = null;\r\n\t\t\t\t\t} else if (now >= running_program.start) {\r\n\t\t\t\t\t\tconst p = now - running_program.start;\r\n\t\t\t\t\t\tt = running_program.a + running_program.d * easing(p / running_program.duration);\r\n\t\t\t\t\t\ttick(t, 1 - t);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn !!(running_program || pending_program);\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\treturn {\r\n\t\trun(b) {\r\n\t\t\tif (is_function(config)) {\r\n\t\t\t\twait().then(() => {\r\n\t\t\t\t\tconst opts = { direction: b ? 'in' : 'out' };\r\n\t\t\t\t\t// @ts-ignore\r\n\t\t\t\t\tconfig = config(opts);\r\n\t\t\t\t\tgo(b);\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\tgo(b);\r\n\t\t\t}\r\n\t\t},\r\n\t\tend() {\r\n\t\t\tclear_animation();\r\n\t\t\trunning_program = pending_program = null;\r\n\t\t}\r\n\t};\r\n}\r\n\r\n/** @typedef {1} INTRO */\r\n/** @typedef {0} OUTRO */\r\n/** @typedef {{ direction: 'in' | 'out' | 'both' }} TransitionOptions */\r\n/** @typedef {(node: Element, params: any, options: TransitionOptions) => import('../transition/public.js').TransitionConfig} TransitionFn */\r\n\r\n/**\r\n * @typedef {Object} Outro\r\n * @property {number} r\r\n * @property {Function[]} c\r\n * @property {Object} p\r\n */\r\n\r\n/**\r\n * @typedef {Object} PendingProgram\r\n * @property {number} start\r\n * @property {INTRO|OUTRO} b\r\n * @property {Outro} [group]\r\n */\r\n\r\n/**\r\n * @typedef {Object} Program\r\n * @property {number} a\r\n * @property {INTRO|OUTRO} b\r\n * @property {1|-1} d\r\n * @property {number} duration\r\n * @property {number} start\r\n * @property {number} end\r\n * @property {Outro} [group]\r\n */\r\n","import {\r\n\tadd_render_callback,\r\n\tflush,\r\n\tflush_render_callbacks,\r\n\tschedule_update,\r\n\tdirty_components\r\n} from './scheduler.js';\r\nimport { current_component, set_current_component } from './lifecycle.js';\r\nimport { blank_object, is_empty, is_function, run, run_all, noop } from './utils.js';\r\nimport {\r\n\tchildren,\r\n\tdetach,\r\n\tstart_hydrating,\r\n\tend_hydrating,\r\n\tget_custom_elements_slots,\r\n\tinsert,\r\n\telement,\r\n\tattr\r\n} from './dom.js';\r\nimport { transition_in } from './transitions.js';\r\n\r\n/** @returns {void} */\r\nexport function bind(component, name, callback) {\r\n\tconst index = component.$$.props[name];\r\n\tif (index !== undefined) {\r\n\t\tcomponent.$$.bound[index] = callback;\r\n\t\tcallback(component.$$.ctx[index]);\r\n\t}\r\n}\r\n\r\n/** @returns {void} */\r\nexport function create_component(block) {\r\n\tblock && block.c();\r\n}\r\n\r\n/** @returns {void} */\r\nexport function claim_component(block, parent_nodes) {\r\n\tblock && block.l(parent_nodes);\r\n}\r\n\r\n/** @returns {void} */\r\nexport function mount_component(component, target, anchor) {\r\n\tconst { fragment, after_update } = component.$$;\r\n\tfragment && fragment.m(target, anchor);\r\n\t// onMount happens before the initial afterUpdate\r\n\tadd_render_callback(() => {\r\n\t\tconst new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\r\n\t\t// if the component was destroyed immediately\r\n\t\t// it will update the `$$.on_destroy` reference to `null`.\r\n\t\t// the destructured on_destroy may still reference to the old array\r\n\t\tif (component.$$.on_destroy) {\r\n\t\t\tcomponent.$$.on_destroy.push(...new_on_destroy);\r\n\t\t} else {\r\n\t\t\t// Edge case - component was destroyed immediately,\r\n\t\t\t// most likely as a result of a binding initialising\r\n\t\t\trun_all(new_on_destroy);\r\n\t\t}\r\n\t\tcomponent.$$.on_mount = [];\r\n\t});\r\n\tafter_update.forEach(add_render_callback);\r\n}\r\n\r\n/** @returns {void} */\r\nexport function destroy_component(component, detaching) {\r\n\tconst $$ = component.$$;\r\n\tif ($$.fragment !== null) {\r\n\t\tflush_render_callbacks($$.after_update);\r\n\t\trun_all($$.on_destroy);\r\n\t\t$$.fragment && $$.fragment.d(detaching);\r\n\t\t// TODO null out other refs, including component.$$ (but need to\r\n\t\t// preserve final state?)\r\n\t\t$$.on_destroy = $$.fragment = null;\r\n\t\t$$.ctx = [];\r\n\t}\r\n}\r\n\r\n/** @returns {void} */\r\nfunction make_dirty(component, i) {\r\n\tif (component.$$.dirty[0] === -1) {\r\n\t\tdirty_components.push(component);\r\n\t\tschedule_update();\r\n\t\tcomponent.$$.dirty.fill(0);\r\n\t}\r\n\tcomponent.$$.dirty[(i / 31) | 0] |= 1 << i % 31;\r\n}\r\n\r\n// TODO: Document the other params\r\n/**\r\n * @param {SvelteComponent} component\r\n * @param {import('./public.js').ComponentConstructorOptions} options\r\n *\r\n * @param {import('./utils.js')['not_equal']} not_equal Used to compare props and state values.\r\n * @param {(target: Element | ShadowRoot) => void} [append_styles] Function that appends styles to the DOM when the component is first initialised.\r\n * This will be the `add_css` function from the compiled component.\r\n *\r\n * @returns {void}\r\n */\r\nexport function init(\r\n\tcomponent,\r\n\toptions,\r\n\tinstance,\r\n\tcreate_fragment,\r\n\tnot_equal,\r\n\tprops,\r\n\tappend_styles = null,\r\n\tdirty = [-1]\r\n) {\r\n\tconst parent_component = current_component;\r\n\tset_current_component(component);\r\n\t/** @type {import('./private.js').T$$} */\r\n\tconst $$ = (component.$$ = {\r\n\t\tfragment: null,\r\n\t\tctx: [],\r\n\t\t// state\r\n\t\tprops,\r\n\t\tupdate: noop,\r\n\t\tnot_equal,\r\n\t\tbound: blank_object(),\r\n\t\t// lifecycle\r\n\t\ton_mount: [],\r\n\t\ton_destroy: [],\r\n\t\ton_disconnect: [],\r\n\t\tbefore_update: [],\r\n\t\tafter_update: [],\r\n\t\tcontext: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\r\n\t\t// everything else\r\n\t\tcallbacks: blank_object(),\r\n\t\tdirty,\r\n\t\tskip_bound: false,\r\n\t\troot: options.target || parent_component.$$.root\r\n\t});\r\n\tappend_styles && append_styles($$.root);\r\n\tlet ready = false;\r\n\t$$.ctx = instance\r\n\t\t? instance(component, options.props || {}, (i, ret, ...rest) => {\r\n\t\t\t\tconst value = rest.length ? rest[0] : ret;\r\n\t\t\t\tif ($$.ctx && not_equal($$.ctx[i], ($$.ctx[i] = value))) {\r\n\t\t\t\t\tif (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);\r\n\t\t\t\t\tif (ready) make_dirty(component, i);\r\n\t\t\t\t}\r\n\t\t\t\treturn ret;\r\n\t\t  })\r\n\t\t: [];\r\n\t$$.update();\r\n\tready = true;\r\n\trun_all($$.before_update);\r\n\t// `false` as a special case of no DOM component\r\n\t$$.fragment = create_fragment ? create_fragment($$.ctx) : false;\r\n\tif (options.target) {\r\n\t\tif (options.hydrate) {\r\n\t\t\tstart_hydrating();\r\n\t\t\t// TODO: what is the correct type here?\r\n\t\t\t// @ts-expect-error\r\n\t\t\tconst nodes = children(options.target);\r\n\t\t\t$$.fragment && $$.fragment.l(nodes);\r\n\t\t\tnodes.forEach(detach);\r\n\t\t} else {\r\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n\t\t\t$$.fragment && $$.fragment.c();\r\n\t\t}\r\n\t\tif (options.intro) transition_in(component.$$.fragment);\r\n\t\tmount_component(component, options.target, options.anchor);\r\n\t\tend_hydrating();\r\n\t\tflush();\r\n\t}\r\n\tset_current_component(parent_component);\r\n}\r\n\r\nexport let SvelteElement;\r\n\r\nif (typeof HTMLElement === 'function') {\r\n\tSvelteElement = class extends HTMLElement {\r\n\t\t/** The Svelte component constructor */\r\n\t\t$$ctor;\r\n\t\t/** Slots */\r\n\t\t$$s;\r\n\t\t/** The Svelte component instance */\r\n\t\t$$c;\r\n\t\t/** Whether or not the custom element is connected */\r\n\t\t$$cn = false;\r\n\t\t/** Component props data */\r\n\t\t$$d = {};\r\n\t\t/** `true` if currently in the process of reflecting component props back to attributes */\r\n\t\t$$r = false;\r\n\t\t/** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */\r\n\t\t$$p_d = {};\r\n\t\t/** @type {Record<string, Function[]>} Event listeners */\r\n\t\t$$l = {};\r\n\t\t/** @type {Map<Function, Function>} Event listener unsubscribe functions */\r\n\t\t$$l_u = new Map();\r\n\r\n\t\tconstructor($$componentCtor, $$slots, use_shadow_dom) {\r\n\t\t\tsuper();\r\n\t\t\tthis.$$ctor = $$componentCtor;\r\n\t\t\tthis.$$s = $$slots;\r\n\t\t\tif (use_shadow_dom) {\r\n\t\t\t\tthis.attachShadow({ mode: 'open' });\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\taddEventListener(type, listener, options) {\r\n\t\t\t// We can't determine upfront if the event is a custom event or not, so we have to\r\n\t\t\t// listen to both. If someone uses a custom event with the same name as a regular\r\n\t\t\t// browser event, this fires twice - we can't avoid that.\r\n\t\t\tthis.$$l[type] = this.$$l[type] || [];\r\n\t\t\tthis.$$l[type].push(listener);\r\n\t\t\tif (this.$$c) {\r\n\t\t\t\tconst unsub = this.$$c.$on(type, listener);\r\n\t\t\t\tthis.$$l_u.set(listener, unsub);\r\n\t\t\t}\r\n\t\t\tsuper.addEventListener(type, listener, options);\r\n\t\t}\r\n\r\n\t\tremoveEventListener(type, listener, options) {\r\n\t\t\tsuper.removeEventListener(type, listener, options);\r\n\t\t\tif (this.$$c) {\r\n\t\t\t\tconst unsub = this.$$l_u.get(listener);\r\n\t\t\t\tif (unsub) {\r\n\t\t\t\t\tunsub();\r\n\t\t\t\t\tthis.$$l_u.delete(listener);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (this.$$l[type]) {\r\n\t\t\t\tconst idx = this.$$l[type].indexOf(listener);\r\n\t\t\t\tif (idx >= 0) {\r\n\t\t\t\t\tthis.$$l[type].splice(idx, 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tasync connectedCallback() {\r\n\t\t\tthis.$$cn = true;\r\n\t\t\tif (!this.$$c) {\r\n\t\t\t\t// We wait one tick to let possible child slot elements be created/mounted\r\n\t\t\t\tawait Promise.resolve();\r\n\t\t\t\tif (!this.$$cn || this.$$c) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tfunction create_slot(name) {\r\n\t\t\t\t\treturn () => {\r\n\t\t\t\t\t\tlet node;\r\n\t\t\t\t\t\tconst obj = {\r\n\t\t\t\t\t\t\tc: function create() {\r\n\t\t\t\t\t\t\t\tnode = element('slot');\r\n\t\t\t\t\t\t\t\tif (name !== 'default') {\r\n\t\t\t\t\t\t\t\t\tattr(node, 'name', name);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t/**\r\n\t\t\t\t\t\t\t * @param {HTMLElement} target\r\n\t\t\t\t\t\t\t * @param {HTMLElement} [anchor]\r\n\t\t\t\t\t\t\t */\r\n\t\t\t\t\t\t\tm: function mount(target, anchor) {\r\n\t\t\t\t\t\t\t\tinsert(target, node, anchor);\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\td: function destroy(detaching) {\r\n\t\t\t\t\t\t\t\tif (detaching) {\r\n\t\t\t\t\t\t\t\t\tdetach(node);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t\treturn obj;\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t\tconst $$slots = {};\r\n\t\t\t\tconst existing_slots = get_custom_elements_slots(this);\r\n\t\t\t\tfor (const name of this.$$s) {\r\n\t\t\t\t\tif (name in existing_slots) {\r\n\t\t\t\t\t\t$$slots[name] = [create_slot(name)];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfor (const attribute of this.attributes) {\r\n\t\t\t\t\t// this.$$data takes precedence over this.attributes\r\n\t\t\t\t\tconst name = this.$$g_p(attribute.name);\r\n\t\t\t\t\tif (!(name in this.$$d)) {\r\n\t\t\t\t\t\tthis.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, 'toProp');\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// Port over props that were set programmatically before ce was initialized\r\n\t\t\t\tfor (const key in this.$$p_d) {\r\n\t\t\t\t\tif (!(key in this.$$d) && this[key] !== undefined) {\r\n\t\t\t\t\t\tthis.$$d[key] = this[key]; // don't transform, these were set through JavaScript\r\n\t\t\t\t\t\tdelete this[key]; // remove the property that shadows the getter/setter\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tthis.$$c = new this.$$ctor({\r\n\t\t\t\t\ttarget: this.shadowRoot || this,\r\n\t\t\t\t\tprops: {\r\n\t\t\t\t\t\t...this.$$d,\r\n\t\t\t\t\t\t$$slots,\r\n\t\t\t\t\t\t$$scope: {\r\n\t\t\t\t\t\t\tctx: []\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// Reflect component props as attributes\r\n\t\t\t\tconst reflect_attributes = () => {\r\n\t\t\t\t\tthis.$$r = true;\r\n\t\t\t\t\tfor (const key in this.$$p_d) {\r\n\t\t\t\t\t\tthis.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];\r\n\t\t\t\t\t\tif (this.$$p_d[key].reflect) {\r\n\t\t\t\t\t\t\tconst attribute_value = get_custom_element_value(\r\n\t\t\t\t\t\t\t\tkey,\r\n\t\t\t\t\t\t\t\tthis.$$d[key],\r\n\t\t\t\t\t\t\t\tthis.$$p_d,\r\n\t\t\t\t\t\t\t\t'toAttribute'\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tif (attribute_value == null) {\r\n\t\t\t\t\t\t\t\tthis.removeAttribute(this.$$p_d[key].attribute || key);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tthis.setAttribute(this.$$p_d[key].attribute || key, attribute_value);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.$$r = false;\r\n\t\t\t\t};\r\n\t\t\t\tthis.$$c.$$.after_update.push(reflect_attributes);\r\n\t\t\t\treflect_attributes(); // once initially because after_update is added too late for first render\r\n\r\n\t\t\t\tfor (const type in this.$$l) {\r\n\t\t\t\t\tfor (const listener of this.$$l[type]) {\r\n\t\t\t\t\t\tconst unsub = this.$$c.$on(type, listener);\r\n\t\t\t\t\t\tthis.$$l_u.set(listener, unsub);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tthis.$$l = {};\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte\r\n\t\t// and setting attributes through setAttribute etc, this is helpful\r\n\t\tattributeChangedCallback(attr, _oldValue, newValue) {\r\n\t\t\tif (this.$$r) return;\r\n\t\t\tattr = this.$$g_p(attr);\r\n\t\t\tthis.$$d[attr] = get_custom_element_value(attr, newValue, this.$$p_d, 'toProp');\r\n\t\t\tthis.$$c?.$set({ [attr]: this.$$d[attr] });\r\n\t\t}\r\n\r\n\t\tdisconnectedCallback() {\r\n\t\t\tthis.$$cn = false;\r\n\t\t\t// In a microtask, because this could be a move within the DOM\r\n\t\t\tPromise.resolve().then(() => {\r\n\t\t\t\tif (!this.$$cn && this.$$c) {\r\n\t\t\t\t\tthis.$$c.$destroy();\r\n\t\t\t\t\tthis.$$c = undefined;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t$$g_p(attribute_name) {\r\n\t\t\treturn (\r\n\t\t\t\tObject.keys(this.$$p_d).find(\r\n\t\t\t\t\t(key) =>\r\n\t\t\t\t\t\tthis.$$p_d[key].attribute === attribute_name ||\r\n\t\t\t\t\t\t(!this.$$p_d[key].attribute && key.toLowerCase() === attribute_name)\r\n\t\t\t\t) || attribute_name\r\n\t\t\t);\r\n\t\t}\r\n\t};\r\n}\r\n\r\n/**\r\n * @param {string} prop\r\n * @param {any} value\r\n * @param {Record<string, CustomElementPropDefinition>} props_definition\r\n * @param {'toAttribute' | 'toProp'} [transform]\r\n */\r\nfunction get_custom_element_value(prop, value, props_definition, transform) {\r\n\tconst type = props_definition[prop]?.type;\r\n\tvalue = type === 'Boolean' && typeof value !== 'boolean' ? value != null : value;\r\n\tif (!transform || !props_definition[prop]) {\r\n\t\treturn value;\r\n\t} else if (transform === 'toAttribute') {\r\n\t\tswitch (type) {\r\n\t\t\tcase 'Object':\r\n\t\t\tcase 'Array':\r\n\t\t\t\treturn value == null ? null : JSON.stringify(value);\r\n\t\t\tcase 'Boolean':\r\n\t\t\t\treturn value ? '' : null;\r\n\t\t\tcase 'Number':\r\n\t\t\t\treturn value == null ? null : value;\r\n\t\t\tdefault:\r\n\t\t\t\treturn value;\r\n\t\t}\r\n\t} else {\r\n\t\tswitch (type) {\r\n\t\t\tcase 'Object':\r\n\t\t\tcase 'Array':\r\n\t\t\t\treturn value && JSON.parse(value);\r\n\t\t\tcase 'Boolean':\r\n\t\t\t\treturn value; // conversion already handled above\r\n\t\t\tcase 'Number':\r\n\t\t\t\treturn value != null ? +value : value;\r\n\t\t\tdefault:\r\n\t\t\t\treturn value;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * @internal\r\n *\r\n * Turn a Svelte component into a custom element.\r\n * @param {import('./public.js').ComponentType} Component  A Svelte component constructor\r\n * @param {Record<string, CustomElementPropDefinition>} props_definition  The props to observe\r\n * @param {string[]} slots  The slots to create\r\n * @param {string[]} accessors  Other accessors besides the ones for props the component has\r\n * @param {boolean} use_shadow_dom  Whether to use shadow DOM\r\n * @param {(ce: new () => HTMLElement) => new () => HTMLElement} [extend]\r\n */\r\nexport function create_custom_element(\r\n\tComponent,\r\n\tprops_definition,\r\n\tslots,\r\n\taccessors,\r\n\tuse_shadow_dom,\r\n\textend\r\n) {\r\n\tlet Class = class extends SvelteElement {\r\n\t\tconstructor() {\r\n\t\t\tsuper(Component, slots, use_shadow_dom);\r\n\t\t\tthis.$$p_d = props_definition;\r\n\t\t}\r\n\t\tstatic get observedAttributes() {\r\n\t\t\treturn Object.keys(props_definition).map((key) =>\r\n\t\t\t\t(props_definition[key].attribute || key).toLowerCase()\r\n\t\t\t);\r\n\t\t}\r\n\t};\r\n\tObject.keys(props_definition).forEach((prop) => {\r\n\t\tObject.defineProperty(Class.prototype, prop, {\r\n\t\t\tget() {\r\n\t\t\t\treturn this.$$c && prop in this.$$c ? this.$$c[prop] : this.$$d[prop];\r\n\t\t\t},\r\n\t\t\tset(value) {\r\n\t\t\t\tvalue = get_custom_element_value(prop, value, props_definition);\r\n\t\t\t\tthis.$$d[prop] = value;\r\n\t\t\t\tthis.$$c?.$set({ [prop]: value });\r\n\t\t\t}\r\n\t\t});\r\n\t});\r\n\taccessors.forEach((accessor) => {\r\n\t\tObject.defineProperty(Class.prototype, accessor, {\r\n\t\t\tget() {\r\n\t\t\t\treturn this.$$c?.[accessor];\r\n\t\t\t}\r\n\t\t});\r\n\t});\r\n\tif (extend) {\r\n\t\t// @ts-expect-error - assigning here is fine\r\n\t\tClass = extend(Class);\r\n\t}\r\n\tComponent.element = /** @type {any} */ (Class);\r\n\treturn Class;\r\n}\r\n\r\n/**\r\n * Base class for Svelte components. Used when dev=false.\r\n *\r\n * @template {Record<string, any>} [Props=any]\r\n * @template {Record<string, any>} [Events=any]\r\n */\r\nexport class SvelteComponent {\r\n\t/**\r\n\t * ### PRIVATE API\r\n\t *\r\n\t * Do not use, may change at any time\r\n\t *\r\n\t * @type {any}\r\n\t */\r\n\t$$ = undefined;\r\n\t/**\r\n\t * ### PRIVATE API\r\n\t *\r\n\t * Do not use, may change at any time\r\n\t *\r\n\t * @type {any}\r\n\t */\r\n\t$$set = undefined;\r\n\r\n\t/** @returns {void} */\r\n\t$destroy() {\r\n\t\tdestroy_component(this, 1);\r\n\t\tthis.$destroy = noop;\r\n\t}\r\n\r\n\t/**\r\n\t * @template {Extract<keyof Events, string>} K\r\n\t * @param {K} type\r\n\t * @param {((e: Events[K]) => void) | null | undefined} callback\r\n\t * @returns {() => void}\r\n\t */\r\n\t$on(type, callback) {\r\n\t\tif (!is_function(callback)) {\r\n\t\t\treturn noop;\r\n\t\t}\r\n\t\tconst callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\r\n\t\tcallbacks.push(callback);\r\n\t\treturn () => {\r\n\t\t\tconst index = callbacks.indexOf(callback);\r\n\t\t\tif (index !== -1) callbacks.splice(index, 1);\r\n\t\t};\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Partial<Props>} props\r\n\t * @returns {void}\r\n\t */\r\n\t$set(props) {\r\n\t\tif (this.$$set && !is_empty(props)) {\r\n\t\t\tthis.$$.skip_bound = true;\r\n\t\t\tthis.$$set(props);\r\n\t\t\tthis.$$.skip_bound = false;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * @typedef {Object} CustomElementPropDefinition\r\n * @property {string} [attribute]\r\n * @property {boolean} [reflect]\r\n * @property {'String'|'Boolean'|'Number'|'Array'|'Object'} [type]\r\n */\r\n","// generated during release, do not modify\r\n\r\n/**\r\n * The current version, as set in package.json.\r\n *\r\n * https://svelte.dev/docs/svelte-compiler#svelte-version\r\n * @type {string}\r\n */\r\nexport const VERSION = '4.2.20';\r\nexport const PUBLIC_VERSION = '4';\r\n","import { PUBLIC_VERSION } from '../../../shared/version.js';\r\n\r\nif (typeof window !== 'undefined')\r\n\t// @ts-ignore\r\n\t(window.__svelte || (window.__svelte = { v: new Set() })).v.add(PUBLIC_VERSION);\r\n"],"names":["element"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7]}